# 静态方法

之前我们在类中定义的方法都是对象方法，换句话说这些方法都是对象可以接收的消息。除了对象方法之外，类中还可以有静态方法和类方法，这两类方法是发给类的消息，二者并没有实质性的区别。在面向对象的世界里，一切皆为对象，我们定义的每一个类其实也是一个对象，而静态方法和类方法就是发送给类对象的消息。那么，什么样的消息会直接发送给类对象呢？

举一个例子，定义一个三角形类，通过传入三条边的长度来构造三角形，并提供计算周长和面积的方法。计算周长和面积肯定是三角形对象的方法，这一点毫无疑问。但是在创建三角形对象时，传入的三条边长未必能构造出三角形，为此我们可以先写一个方法来验证给定的三条边长是否可以构成三角形，这种方法很显然就不是对象方法，因为在调用这个方法时三角形对象还没有创建出来。我们可以把这类方法设计为静态方法或类方法，也就是说这类方法不是发送给三角形对象的消息，而是发送给三角形类的消息，代码如下所示。



## **a. 静态方法的例子**

~~~python
import math

class Triangle:
    """
    三角形类
    """
    
    def __init__(self, side_a, side_b, side_c):
        """
        初始化三角形
        在构造对象前，应该先使用is_valid_triangle方法验证边长是否有效
        """
        if not Triangle.is_valid_triangle(side_a, side_b, side_c):
            raise ValueError(f"边长({side_a}, {side_b}, {side_c})无法构成三角形")
        
        self.side_a = side_a
        self.side_b = side_b
        self.side_c = side_c
    
    @staticmethod
    def is_valid_triangle(a, b, c):
        """
        静态方法：验证三条边长是否能构成三角形
        三角形条件：任意两边之和大于第三边，且所有边长为正数
        """
        # 检查边长是否为正数
        if a <= 0 or b <= 0 or c <= 0:
            return False
        
        # 检查三角形不等式
        if a + b <= c:
            return False
        if a + c <= b:
            return False
        if b + c <= a:
            return False
        
        return True
    
    def perimeter(self):
        """实例方法：计算三角形的周长"""
        return self.side_a + self.side_b + self.side_c
    
    def area(self):
        """实例方法：计算三角形的面积（使用海伦公式）"""
        p = self.perimeter() / 2  # 半周长
        area = math.sqrt(p * (p - self.side_a) * (p - self.side_b) * (p - self.side_c))
        return area
    
    def __str__(self):
        return f"三角形(边长: {self.side_a}, {self.side_b}, {self.side_c})"


# 使用示例
if __name__ == "__main__":
    # 使用静态方法验证边长，不需要创建对象
    print("验证边长是否能构成三角形:")
    print(f"边长(3, 4, 5)是否有效: {Triangle.is_valid_triangle(3, 4, 5)}")  # True
    print(f"边长(1, 1, 3)是否有效: {Triangle.is_valid_triangle(1, 1, 3)}")  # False
    print(f"边长(0, 2, 2)是否有效: {Triangle.is_valid_triangle(0, 2, 2)}")  # False
    print()
    
    # 创建有效的三角形对象
    try:
        triangle1 = Triangle(3, 4, 5)
        print(f"创建成功: {triangle1}")
        print(f"周长: {triangle1.perimeter()}")
        print(f"面积: {triangle1.area()}")
        print()
    except ValueError as e:
        print(f"创建失败: {e}")
    
    # 尝试创建无效的三角形对象
    try:
        triangle2 = Triangle(1, 1, 3)
        print(f"创建成功: {triangle2}")
    except ValueError as e:
        print(f"创建失败: {e}")
    
    # 另一个有效的三角形
    try:
        triangle3 = Triangle(5, 5, 5)  # 等边三角形
        print(f"创建成功: {triangle3}")
        print(f"周长: {triangle3.perimeter()}")
        print(f"面积: {triangle3.area():.2f}")
    except ValueError as e:
        print(f"创建失败: {e}")
~~~



## **b. 代码说明：**

1. **静态方法 `is_valid_triangle`**：
   - 使用 `@staticmethod` 装饰器定义
   - 不需要 `self` 参数，因为它不依赖于任何特定的三角形实例
   - 可以在创建三角形对象之前调用，验证给定的三条边长是否能构成三角形
   - 验证逻辑包括：边长是否为正数，是否满足三角形不等式定理
2. **实例方法**：
   - `__init__`：构造函数，在创建对象时验证边长有效性
   - `perimeter`：计算周长，需要具体的三角形对象
   - `area`：计算面积，使用海伦公式，需要具体的三角形对象
3. **使用场景**：
   - 在创建三角形对象前，可以先调用静态方法验证边长
   - 在构造函数中也会调用静态方法进行验证
   - 静态方法属于类，而不是类的任何特定实例



## **c. 输出结果：**

```
验证边长是否能构成三角形:
边长(3, 4, 5)是否有效: True
边长(1, 1, 3)是否有效: False
边长(0, 2, 2)是否有效: False

创建成功: 三角形(边长: 3, 4, 5)
周长: 12
面积: 6.0

创建失败: 边长(1, 1, 3)无法构成三角形
创建成功: 三角形(边长: 5, 5, 5)
周长: 15
面积: 10.83
```





## d. 总结一下区别：

| 方法类型                   | 是否需要实例 (`self`) | 是否需要类 (`cls`) | 典型用途                                     |
| -------------------------- | --------------------- | ------------------ | -------------------------------------------- |
| 实例方法                   | ✅ 是                  | ❌ 否               | 操作对象属性，例如 `perimeter()`、`area()`   |
| 类方法 (`@classmethod`)    | ❌ 否                  | ✅ 是               | 修改类属性、构造对象                         |
| 静态方法 (`@staticmethod`) | ❌ 否                  | ❌ 否               | 工具函数、逻辑检查，与类概念相关但不依赖对象 |

