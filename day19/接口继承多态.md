# 接口 + 继承 + 多态

## 第一部分：



### 一、什么是“接口”（Interface）

在 Python 中，**接口并不是语法上的关键字**，
 而是一种“**约定**”或“**规范**”：

> 接口规定了一个类应该具备哪些方法（行为），但不规定具体实现。

也就是说，接口更像是一种“协议”或“承诺”：

- “我保证我这个类会有这些方法”
- “至于方法里具体怎么实现，每个类自己决定”





### 二、用一个例子说明

比如我们想让所有“人类”都有一个共同的行为：**工作（work）**

不同的人工作方式不一样：

- 老师：讲课
- 学生：学习
- 工人：搬砖

于是我们可以定义一个接口（或抽象基类）：

```python
from abc import ABC, abstractmethod

class Worker(ABC):
    """接口：定义工作行为"""
    
    @abstractmethod
    def work(self):
        """子类必须实现这个方法"""
        pass
```

> `ABC` 表示抽象基类（Abstract Base Class）
>  `@abstractmethod` 表示“抽象方法”，子类必须实现它。





### 三、让具体类实现接口

```python
class Student(Worker):
    def work(self):
        print("学生在学习知识。")

class Teacher(Worker):
    def work(self):
        print("老师在讲授课程。")

class Farmer(Worker):
    def work(self):
        print("农民在种地。")
```





### 四、多态 + 接口联合使用

```python
people = [Student(), Teacher(), Farmer()]

for p in people:
    p.work()  # 多态：同一个方法，不同行为
```

输出：

```
学生在学习知识。
老师在讲授课程。
农民在种地。
```

> ✅ 这就是「**接口 + 多态**」的典型场景。





### 五、接口的作用总结

| 功能           | 说明                                       |
| -------------- | ------------------------------------------ |
| **规范行为**   | 定义所有子类必须实现哪些方法               |
| **实现多态**   | 通过接口调用不同对象的同名方法             |
| **提高扩展性** | 新增类时，只要实现接口即可，无需改动旧代码 |
| **解耦**       | 调用方只依赖接口，而不依赖具体实现类       |





###  六、接口 vs 继承 vs 多态（对比表）

| 概念     | 作用     | 关键点                         | Python实现方式                |
| -------- | -------- | ------------------------------ | ----------------------------- |
| **继承** | 复用代码 | 子类继承父类方法和属性         | `class Child(Parent):`        |
| **多态** | 统一调用 | 不同类用相同方法名表现不同行为 | 同名方法、不同实现            |
| **接口** | 约束规范 | 定义行为要求，不写实现         | `abc.ABC` + `@abstractmethod` |





### 简短一句话总结：

> **继承** 是“拿来用”，
>  **多态** 是“同名不同用”，
>  **接口** 是“必须要用（规范）”。

------



是否希望我帮你把你上面的 `Person / Student / Teacher` 示例改造成带接口（`work()`）的版本，让你一眼看出区别？





## 第二部分：

### 例子：人都有“工作”（接口）

#### 一、定义一个接口（抽象类）

```python
from abc import ABC, abstractmethod

class Workable(ABC):
    """接口类：规定所有人都必须会‘工作’"""
    
    @abstractmethod
    def work(self):
        """所有子类都必须实现这个方法"""
        pass
```

🧠 说明：

- `ABC` 表示“抽象基类（Abstract Base Class）”
- `@abstractmethod` 表示“抽象方法”——子类**必须实现**，否则不能实例化。



#### 二、定义父类（普通继承）

```python
class Person:
    """父类：人"""
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def introduce(self):
        print(f"你好，我叫 {self.name}，今年 {self.age} 岁。")
```





#### 三、定义子类：学生、老师、工程师

（都继承 `Person`，同时实现 `Workable` 接口）

```python
class Student(Person, Workable):
    def work(self):
        print(f"{self.name} 正在学习知识。")

class Teacher(Person, Workable):
    def work(self):
        print(f"{self.name} 正在讲授课程。")

class Engineer(Person, Workable):
    def work(self):
        print(f"{self.name} 正在写代码。")
```





#### 四、实际使用（多态）

```python
if __name__ == "__main__":
    people = [
        Student("白元芳", 21),
        Teacher("狄仁杰", 35),
        Engineer("武则天", 30)
    ]
    
    for person in people:
        person.introduce()
        person.work()
        print("-" * 20)
```





输出结果：

```
你好，我叫 白元芳，今年 21 岁。
白元芳 正在学习知识。
--------------------
你好，我叫 狄仁杰，今年 35 岁。
狄仁杰 正在讲授课程。
--------------------
你好，我叫 武则天，今年 30 岁。
武则天 正在写代码。
--------------------
```



#### 五、完整示例：接口 + 继承 + 多态

~~~python
from abc import ABC, abstractmethod

class Person(ABC):
    """人（抽象基类，定义接口）"""

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def eat(self):
        print(f'{self.name}正在吃饭.')

    def sleep(self):
        print(f'{self.name}正在睡觉.')

    @abstractmethod
    def work(self):
        """抽象方法：不同角色有不同的工作"""
        pass


class Student(Person):
    """学生类"""

    def __init__(self, name, age):
        super().__init__(name, age)

    def study(self, course_name):
        print(f'{self.name}正在学习{course_name}.')

    def work(self):
        print(f'{self.name}的工作是学习和完成作业.')


class Teacher(Person):
    """老师类"""

    def __init__(self, name, age, title):
        super().__init__(name, age)
        self.title = title

    def teach(self, course_name):
        print(f'{self.name}{self.title}正在讲授{course_name}.')

    def work(self):
        print(f'{self.name}{self.title}的工作是教授课程和指导学生.')


# 测试多态效果
people = [
    Student('白元芳', 21),
    Teacher('武则天', 35, '副教授')
]

for p in people:
    p.eat()
    p.work()  # 多态调用，不同子类表现不同

~~~



**输出结果**

```
白元芳正在吃饭.
白元芳的工作是学习和完成作业.
武则天正在吃饭.
武则天副教授的工作是教授课程和指导学生.
```





**说明**

- `Person` 是一个抽象类（接口角色），定义了公共属性和行为。
- `@abstractmethod` 修饰的 `work()` 必须在子类中实现。
- 子类 `Student` 和 `Teacher` 各自实现了不同的 `work()` 行为。
- `for p in people:` 处体现多态：**同样的调用 `p.work()`，表现不同**。



####  分析总结

| 特性     | 在代码中的体现                        | 说明                               |
| -------- | ------------------------------------- | ---------------------------------- |
| **继承** | `Student(Person)`                     | 子类继承了父类属性和方法           |
| **接口** | `class Student(Person, Workable)`     | 子类必须实现接口的 `work()` 方法   |
| **多态** | `for person in people: person.work()` | 不同对象执行同名方法表现出不同结果 |

------

✅ **一句话总结：**

> 接口定义“必须做什么”，继承决定“有哪些功能”，多态体现“怎么去做”。

------

是否希望我帮你扩展这个例子，加一个“接口检测”（比如判断一个对象是否实现了接口）？

