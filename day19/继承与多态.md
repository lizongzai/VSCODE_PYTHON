## 1. 继承 (Inheritance)

### 基本概念

继承允许我们定义一个类（子类）来继承另一个类（父类）的属性和方法。

~~~python

class Animal:
    """动物基类"""
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def speak(self):
        raise NotImplementedError("子类必须实现speak方法")
    
    def eat(self):
        print(f"{self.name}正在吃东西")
    
    def sleep(self):
        print(f"{self.name}正在睡觉")

class Dog(Animal):  # Dog继承Animal
    """狗类"""
    
    def __init__(self, name, age, breed):
        super().__init__(name, age)  # 调用父类的构造方法
        self.breed = breed
    
    def speak(self):
        return f"{self.name}说: 汪汪!"
    
    def fetch(self):
        print(f"{self.name}正在接飞盘")

class Cat(Animal):  # Cat继承Animal
    """猫类"""
    
    def __init__(self, name, age, color):
        super().__init__(name, age)
        self.color = color
    
    def speak(self):
        return f"{self.name}说: 喵喵!"
    
    def climb(self):
        print(f"{self.name}正在爬树")

# 使用继承
print("=== 继承示例 ===")
dog = Dog("旺财", 3, "金毛")
cat = Cat("咪咪", 2, "白色")

print(dog.speak())  # 旺财说: 汪汪!
print(cat.speak())  # 咪咪说: 喵喵!

# 继承的方法
dog.eat()    # 从Animal继承
cat.sleep()  # 从Animal继承

# 子类特有的方法
dog.fetch()  # Dog特有的
cat.climb()  # Cat特有的
~~~



### 继承的类型

~~~python
# 1. 单继承
class Vehicle:
    """交通工具基类"""
    def __init__(self, brand, speed):
        self.brand = brand
        self.speed = speed
    
    def move(self):
        return f"{self.brand}正在以{self.speed}km/h移动"

class Car(Vehicle):  # 单继承
    def __init__(self, brand, speed, doors):
        super().__init__(brand, speed)
        self.doors = doors
    
    def honk(self):
        return "滴滴!"

# 2. 多层继承
class SportsCar(Car):  # 继承Car，Car继承Vehicle
    def __init__(self, brand, speed, doors, turbo):
        super().__init__(brand, speed, doors)
        self.turbo = turbo
    
    def activate_turbo(self):
        return "涡轮增压启动!"

# 3. 方法重写 (Override)
class ElectricCar(Car):
    def __init__(self, brand, speed, doors, battery_capacity):
        super().__init__(brand, speed, doors)
        self.battery_capacity = battery_capacity
    
    def move(self):  # 重写父类方法
        return f"{self.brand}电动车静音移动中..."

print("\n=== 继承类型示例 ===")
car = Car("丰田", 120, 4)
sports_car = SportsCar("保时捷", 280, 2, True)
electric_car = ElectricCar("特斯拉", 200, 4, 100)

print(car.move())           # 丰田正在以120km/h移动
print(sports_car.move())    # 保时捷正在以280km/h移动
print(electric_car.move())  # 特斯拉电动车静音移动中... (重写后的方法)
~~~


## 2. 多态 (Polymorphism)

### 多态的概念

多态意味着"多种形态"，指同一个方法在不同类中有不同的实现。

~~~python

class Shape:
    """图形基类"""
    def area(self):
        raise NotImplementedError("子类必须实现area方法")
    
    def perimeter(self):
        raise NotImplementedError("子类必须实现perimeter方法")

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
    
    def __str__(self):
        return f"矩形(宽:{self.width}, 高:{self.height})"

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2
    
    def perimeter(self):
        return 2 * 3.14159 * self.radius
    
    def __str__(self):
        return f"圆形(半径:{self.radius})"

class Triangle(Shape):
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
    
    def area(self):
        # 海伦公式
        s = self.perimeter() / 2
        return (s * (s - self.a) * (s - self.b) * (s - self.c)) ** 0.5
    
    def perimeter(self):
        return self.a + self.b + self.c
    
    def __str__(self):
        return f"三角形(边:{self.a},{self.b},{self.c})"

# 多态的威力
def print_shape_info(shape):
    """这个函数可以处理任何Shape子类"""
    print(f"{shape} -> 面积: {shape.area():.2f}, 周长: {shape.perimeter():.2f}")

print("=== 多态示例 ===")
shapes = [
    Rectangle(4, 5),
    Circle(3),
    Triangle(3, 4, 5)
]

for shape in shapes:
    print_shape_info(shape)  # 同样的接口，不同的实现
~~~



### 更复杂的多态示例

~~~python

from abc import ABC, abstractmethod
import math

class Employee(ABC):
    """员工基类"""
    
    def __init__(self, name, base_salary):
        self.name = name
        self.base_salary = base_salary
    
    @abstractmethod
    def calculate_salary(self):
        """计算工资 - 抽象方法，子类必须实现"""
        pass
    
    @abstractmethod
    def get_role(self):
        """获取角色"""
        pass

class Developer(Employee):
    def __init__(self, name, base_salary, programming_language, overtime_hours=0):
        super().__init__(name, base_salary)
        self.programming_language = programming_language
        self.overtime_hours = overtime_hours
    
    def calculate_salary(self):
        """开发员工资 = 基本工资 + 加班费"""
        overtime_pay = self.overtime_hours * 100
        return self.base_salary + overtime_pay
    
    def get_role(self):
        return f"开发工程师({self.programming_language})"

class Manager(Employee):
    def __init__(self, name, base_salary, team_size, bonus_percentage=0.1):
        super().__init__(name, base_salary)
        self.team_size = team_size
        self.bonus_percentage = bonus_percentage
    
    def calculate_salary(self):
        """经理工资 = 基本工资 + 团队规模奖金"""
        team_bonus = self.base_salary * self.bonus_percentage * self.team_size
        return self.base_salary + team_bonus
    
    def get_role(self):
        return f"项目经理(团队规模:{self.team_size})"

class Salesperson(Employee):
    def __init__(self, name, base_salary, sales_amount, commission_rate=0.05):
        super().__init__(name, base_salary)
        self.sales_amount = sales_amount
        self.commission_rate = commission_rate
    
    def calculate_salary(self):
        """销售员工资 = 基本工资 + 销售提成"""
        commission = self.sales_amount * self.commission_rate
        return self.base_salary + commission
    
    def get_role(self):
        return f"销售专员(销售额:{self.sales_amount})"

# 使用多态处理不同类型的员工
def process_payroll(employees):
    """处理工资单 - 多态的经典应用"""
    print("=== 工资单 ===")
    total_payroll = 0
    
    for employee in employees:
        salary = employee.calculate_salary()  # 多态调用
        print(f"{employee.name} [{employee.get_role()}] -> 工资: ¥{salary:,.2f}")
        total_payroll += salary
    
    print(f"总工资支出: ¥{total_payroll:,.2f}")
    return total_payroll

print("\n=== 员工管理系统多态示例 ===")
employees = [
    Developer("张三", 15000, "Python", 10),
    Manager("李四", 20000, 5),
    Salesperson("王五", 12000, 500000),
    Developer("赵六", 16000, "Java", 5)
]

total = process_payroll(employees)
~~~



### 鸭子类型 (Duck Typing)

Python的多态更灵活，不强制要求继承关系：

~~~python

class FileReader:
    """文件读取器"""
    def read(self):
        return "从文件读取数据"

class DatabaseReader:
    """数据库读取器"""
    def read(self):
        return "从数据库读取数据"

class APIClient:
    """API客户端"""
    def fetch_data(self):  # 注意：方法名不同！
        return "从API获取数据"
    
    def read(self):  # 适配器方法
        return self.fetch_data()

def process_data_source(source):
    """处理数据源 - 只要你有read方法，我就能用"""
    if hasattr(source, 'read'):
        return source.read()
    else:
        return "不支持的数据源"

print("\n=== 鸭子类型示例 ===")
sources = [FileReader(), DatabaseReader(), APIClient()]

for source in sources:
    result = process_data_source(source)
    print(f"数据源: {type(source).__name__} -> {result}")
~~~



## 3. 继承 vs 多态 的关系

~~~python

class PaymentMethod(ABC):
    """支付方式基类"""
    
    @abstractmethod
    def pay(self, amount):
        pass
    
    @abstractmethod
    def refund(self, amount):
        pass

class CreditCard(PaymentMethod):
    def pay(self, amount):
        return f"信用卡支付: ¥{amount}"
    
    def refund(self, amount):
        return f"信用卡退款: ¥{amount}"

class Alipay(PaymentMethod):
    def pay(self, amount):
        return f"支付宝支付: ¥{amount}"
    
    def refund(self, amount):
        return f"支付宝退款: ¥{amount}"

class WechatPay(PaymentMethod):
    def pay(self, amount):
        return f"微信支付: ¥{amount}"
    
    def refund(self, amount):
        return f"微信退款: ¥{amount}"

class PaymentProcessor:
    """支付处理器 - 利用多态"""
    
    def process_payment(self, payment_method, amount):
        """处理支付 - 支持任何支付方式"""
        print(payment_method.pay(amount))  # 多态调用
    
    def process_refund(self, payment_method, amount):
        """处理退款 - 支持任何支付方式"""
        print(payment_method.refund(amount))  # 多态调用

print("\n=== 继承+多态综合示例 ===")
processor = PaymentProcessor()
payment_methods = [CreditCard(), Alipay(), WechatPay()]

amount = 100.50
for method in payment_methods:
    processor.process_payment(method, amount)
~~~



## 总结

**继承 (Inheritance):**

- 代码复用：子类继承父类的属性和方法
- 层次结构：建立"is-a"关系（Dog is an Animal）
- 扩展功能：子类可以添加新功能或重写父类功能

**多态 (Polymorphism):**

- 接口统一：不同对象对同一消息做出不同响应
- 灵活性：代码可以处理多种类型的对象
- 可扩展性：添加新类型不影响现有代码

**核心优势：**

- **提高代码复用性**
- **增强系统扩展性**
- **降低代码耦合度**
- **提高开发效率**
