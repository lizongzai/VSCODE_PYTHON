# 文件操作和异常处理


## 1. 文件操作

实际开发中常常会遇到对数据进行持久化的场景，所谓持久化是指将数据从无法长久保存数据的存储介质（通常是内存）转移到可以长久保存数据的存储介质（通常是硬盘）中。实现数据持久化最直接简单的方式就是通过**文件系统**将数据保存到**文件**中。

计算机的**文件系统**是一种存储和组织计算机数据的方法，它使得对数据的访问和查找变得容易，文件系统使用**文件**和**树形目录**的抽象逻辑概念代替了硬盘、光盘、闪存等物理设备的数据块概念，用户使用文件系统来保存数据时，不必关心数据实际保存在硬盘的哪个数据块上，只需要记住这个文件的路径和文件名。在写入新数据之前，用户不必关心硬盘上的哪个数据块没有被使用，硬盘上的存储空间管理（分配和释放）功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。





### 1.1 打开文件



有了文件系统，我们可以非常方便的通过文件来读写数据；在Python中要实现文件操作是非常简单的。我们可以使用Python内置的`open`函数来打开文件，在使用`open`函数时，我们可以通过函数的参数指定**文件名**、**操作模式**和**字符编码**等信息，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件或二进制文件）以及做什么样的操作（读、写或追加），具体如下表所示。

| 操作模式 | 具体含义                         |
| -------- | -------------------------------- |
| `'r'`    | 读取 （默认）                    |
| `'w'`    | 写入（会先截断之前的内容）       |
| `'x'`    | 写入，如果文件已经存在会产生异常 |
| `'a'`    | 追加，将内容写入到已有文件的末尾 |
| `'b'`    | 二进制模式                       |
| `'t'`    | 文本模式（默认）                 |
| `'+'`    | 更新（既可以读又可以写）         |



**使用 `open()` 函数打开文件：**

~~~python
# 基本语法
file = open(filename, mode, encoding)
~~~



**下图展示了如何根据程序的需要来设置`open()`函数的操作模式**

![image-20251023160701061](C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20251023160701061.png)



在使用`open`函数时，如果打开的文件是字符文件（文本文件），可以通过`encoding`参数来指定读写文件使用的字符编码。如果对字符编码和字符集这些概念不了解，可以看看[《字符集和字符编码》](https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html)一文，此处不再进行赘述。

使用`open`函数打开文件成功后会返回一个文件对象，通过这个对象，我们就可以实现对文件的读写操作；如果打开文件失败，`open`函数会引发异常，稍后会对此加以说明。如果要关闭打开的文件，可以使用文件对象的`close`方法，这样可以在结束文件操作时释放掉这个文件



### 1.2 读取文件

用`open()`函数打开文本文件时，需要指定文件名并将文件的操作模式设置为`'r'`，如果不指定，默认值也是`'r'`；如果需要指定字符编码，可以传入`encoding`参数，如果不指定，默认值是None，那么在读取文件时使用的是操作系统默认的编码。需要提醒大家，如果不能保证保存文件时使用的编码方式与`encoding`参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取文件失败。

下面的例子演示了如何读取一个纯文本文件（一般指只有字符原生编码构成的文件，与富文本相比，纯文本不包含字符样式的控制元素，能够被最简单的文本编辑器直接读取）。

~~~python
# 第一种方式：传统方式读取整个文件
file = open('致橡树.txt', 'r', encoding='utf-8')
print(file.read())
file.close() # 如果这里发生异常，文件不会关闭！可能执行不到这里

# 第二种方式：使用 with 语句（推荐）读取整个文件,文件已自动关闭
with open('致橡树.txt', 'r', encoding='utf-8') as file:
    content = file.read()
    print(content)

# 逐行读取
with open('致橡树.txt', 'r', encoding='utf-8') as file:
    for line in file:
        print(line.strip())  # strip() 移除换行符

# 读取所有行到列表
with open('致橡树.txt', 'r', encoding='utf-8') as file:
    lines = file.readlines()
    print(lines)

~~~

> **说明**：[《致橡树》](http://www.china.org.cn/learning_english/2011-02/21/content_21967654.htm)是舒婷老师在1977年3月创建的爱情诗，也是我最喜欢的现代诗之一。除了使用文件对象的`read`方法读取文件之外，还可以使用`for-in`循环逐行读取或者用`readlines`方法将文件按行读取到一个列表容器中.



### 1.3 写入文件

如果要向文件中写入内容，可以在打开文件时使用`w`或者`a`作为操作模式，前者会截断之前的文本内容写入新的内容，后者是在原来内容的尾部追加新的内容。

**传统方式**

~~~python
file = open('致橡树.txt', 'a', encoding='utf-8')
file.write('\n标题：《致橡树》')
file.write('\n作者：舒婷')
file.write('\n时间：1977年3月')
file.close()
~~~

**推荐（第二种方式)**

~~~python
# 写入文件（覆盖）
with open('example.txt', 'w', encoding='utf-8') as file:
    file.write('Hello, World!\n')
    file.write('This is a new line.\n')

# 追加内容
with open('example.txt', 'a', encoding='utf-8') as file:
    file.write('This line is appended.\n')
~~~

### 1.4 使用 with 语句

使用 `with` 语句可以自动管理文件资源，确保文件正确关闭：

~~~python
with open('file.txt', 'r') as file:
    data = file.read()
# 文件会自动关闭
~~~





## 2. 异常处理

请注意上面的代码，如果`open`函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码具有健壮性和容错性，我们可以**使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理**。Python中和异常相关的关键字有五个，分别是`try`、`except`、`else`、`finally`和`raise`，我们先看看下面的代码，再来为大家介绍这些关键字的用法。

~~~python
file = None
try:
    file = open('致橡树.txt', 'r', encoding='utf-8')
    print(file.read())
except FileNotFoundError:
    print('无法打开指定的文件!')
except LookupError:
    print('指定了未知的编码!')
except UnicodeDecodeError:
    print('读取文件时解码错误!')
finally:
    if file:
        file.close()
~~~



在Python中，我们可以将运行时会出现状况的代码放在`try`代码块中，在`try`后面可以跟上一个或多个`except`块来捕获异常并进行相应的处理。例如，在上面的代码中，文件找不到会引发`FileNotFoundError`，指定了未知的编码会引发`LookupError`，而如果读取文件时无法按指定编码方式解码文件会引发`UnicodeDecodeError`，所以我们在`try`后面跟上了三个`except`分别处理这三种不同的异常状况。在`except`后面，我们还可以加上`else`代码块，这是`try` 中的代码没有出现异常时会执行的代码，而且`else`中的代码不会再进行异常捕获，也就是说如果遇到异常状况，程序会因异常而终止并报告异常信息。最后我们使用`finally`代码块来关闭打开的文件，释放掉程序中获取的外部资源。由于`finally`块的代码不论程序正常还是异常都会执行，甚至是调用了`sys`模块的`exit`函数终止Python程序，`finally`块中的代码仍然会被执行（因为`exit`函数的本质是引发了`SystemExit`异常），因此我们把`finally`代码块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。

Python中内置了大量的异常类型，除了上面代码中用到的异常类型以及之前的课程中遇到过的异常类型外，还有许多的异常类型，其继承结构如下所示。

```
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning
```



### 2.1 基本异常处理

```python
try:
    # 可能引发异常的代码
    result = 10 / 0
except ZeroDivisionError:
    # 处理特定异常
    print("不能除以零!")
except (TypeError, ValueError) as e:
    # 处理多种异常
    print(f"类型或值错误: {e}")
except Exception as e:
    # 处理所有其他异常
    print(f"发生错误: {e}")
else:
    # 如果没有异常发生
    print("操作成功!")
finally:
    # 无论是否发生异常都会执行
    print("清理工作完成")
```



### 2.2 常见的文件操作异常

```python
try:
    with open('nonexistent.txt', 'r') as file:
        content = file.read()
except FileNotFoundError:
    print("文件不存在!")
except PermissionError:
    print("没有文件访问权限!")
except IOError as e:
    print(f"IO错误: {e}")
```



### 2.3 自定义异常

```python
class CustomError(Exception):
    """自定义异常类"""
    def __init__(self, message):
        self.message = message
        super().__init__(self.message)

try:
    raise CustomError("这是一个自定义错误")
except CustomError as e:
    print(f"捕获自定义错误: {e}")
```



### 2.4 上下文管理器

上下文管理器是Python中用于管理资源（如文件、网络连接、数据库连接等）的重要机制，它确保资源在使用后被正确清理和释放。

#### 2.4.1 上下文管理器基础

##### 2.4.1.1 使用 `with` 语句

```python
# 文件操作是最常见的上下文管理器使用场景
with open('example.txt', 'r') as file:
    content = file.read()
    # 文件会在退出 with 块时自动关闭
```



#### 2.4.2 实现上下文管理器

##### 2.4.2.1 方法一：使用类（实现 `__enter__` 和 `__exit__` 方法）

```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        """进入上下文时调用，返回要管理的资源"""
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_value, traceback):
        """退出上下文时调用，处理异常和清理资源"""
        if self.file:
            self.file.close()
        
        # 如果返回 True，异常会被抑制；返回 False 或 None，异常会继续传播
        return False

# 使用自定义上下文管理器
with FileManager('example.txt', 'w') as f:
    f.write('Hello, World!')
```



##### 2.4.2.2 方法二：使用 `contextlib` 模块

```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    """使用生成器实现的上下文管理器"""
    file = open(filename, mode)
    try:
        yield file  # 这是 __enter__ 返回的内容
    finally:
        file.close()  # 这是 __exit__ 的清理工作

# 使用
with file_manager('example.txt', 'w') as f:
    f.write('Using contextmanager decorator')
```



#### 2.4.3 高级上下文管理器示例

##### 2.4.3.1 计时器上下文管理器

```python
import time
from contextlib import contextmanager

@contextmanager
def timer(description="Operation"):
    """测量代码执行时间的上下文管理器"""
    start = time.time()
    try:
        yield
    finally:
        end = time.time()
        print(f"{description} took {end - start:.2f} seconds")

# 使用
with timer("Data processing"):
    time.sleep(1)
    # 模拟耗时操作
```



##### 2.4.3.2 数据库连接管理器

```python
class DatabaseConnection:
    def __init__(self, db_url):
        self.db_url = db_url
        self.connection = None
    
    def __enter__(self):
        self.connection = self.connect_to_database(self.db_url)
        return self.connection
    
    def __exit__(self, exc_type, exc_value, traceback):
        if self.connection:
            self.connection.close()
        # 如果是连接错误，可以在这里处理
        if exc_type is not None and issubclass(exc_type, ConnectionError):
            print("数据库连接失败")
            return True  # 抑制异常
    
    def connect_to_database(self, url):
        # 模拟数据库连接
        print(f"连接到数据库: {url}")
        return {"connection": "active", "url": url}

# 使用
with DatabaseConnection("postgresql://localhost/mydb") as db:
    print(f"数据库状态: {db}")
```



#### 2.4.4 临时目录管理器

```python
import tempfile
import os
from contextlib import contextmanager

@contextmanager
def temporary_directory():
    """创建临时目录并在使用后自动清理"""
    temp_dir = tempfile.mkdtemp()
    try:
        yield temp_dir
    finally:
        # 清理临时目录
        import shutil
        shutil.rmtree(temp_dir)

# 使用
with temporary_directory() as temp_dir:
    print(f"工作在临时目录: {temp_dir}")
    # 创建一些临时文件
    temp_file = os.path.join(temp_dir, "temp.txt")
    with open(temp_file, 'w') as f:
        f.write("临时内容")
    # 退出 with 块后，临时目录会自动删除
```



#### 2.4.5 异常处理在上下文管理器中

```python
class RobustFileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        try:
            self.file = open(self.filename, self.mode)
            return self.file
        except FileNotFoundError:
            print(f"文件 {self.filename} 不存在")
            # 可以返回一个默认值或重新抛出异常
            raise
    
    def __exit__(self, exc_type, exc_value, traceback):
        if self.file:
            self.file.close()
        
        # 处理特定异常
        if exc_type is IOError:
            print("发生了IO错误")
            return True  # 抑制异常
        
        return False  # 不抑制其他异常

# 使用
try:
    with RobustFileManager('nonexistent.txt', 'r') as f:
        content = f.read()
except FileNotFoundError:
    print("文件未找到，已处理")
```



#### 2.4.6 嵌套上下文管理器

```python
from contextlib import contextmanager

@contextmanager
def indent_output(indent_level):
    """缩进输出"""
    prefix = " " * indent_level
    try:
        print(f"{prefix}进入缩进级别 {indent_level}")
        yield
    finally:
        print(f"{prefix}退出缩进级别 {indent_level}")

# 嵌套使用
with indent_output(0):
    print("外层操作")
    with indent_output(4):
        print("内层操作")
        with indent_output(8):
            print("更深层的操作")
```



#### 2.4.7  组合多个上下文管理器

##### 2.4.7.1 方法一：嵌套使用

```python
with open('input.txt', 'r') as input_file:
    with open('output.txt', 'w') as output_file:
        content = input_file.read()
        output_file.write(content.upper())
```



##### 2.4.7.2 方法二：使用逗号分隔

```python
with open('input.txt', 'r') as input_file, \
     open('output.txt', 'w') as output_file:
    content = input_file.read()
    output_file.write(content.upper())
```



##### 2.4.7.3 方法三：使用 `contextlib.ExitStack`

```python
from contextlib import ExitStack

def process_multiple_files(files):
    """同时管理多个文件"""
    with ExitStack() as stack:
        file_objects = []
        for filename, mode in files:
            file_obj = stack.enter_context(open(filename, mode))
            file_objects.append(file_obj)
        
        # 所有文件都在这里保持打开状态
        for file_obj in file_objects:
            print(f"处理文件: {file_obj.name}")
        
        # 退出时所有文件会自动关闭
```



#### 2.4.8  实用的内置上下文管理器

##### 2.4.8.1 `suppress` - 抑制特定异常

```python
from contextlib import suppress

# 抑制 FileNotFoundError
with suppress(FileNotFoundError):
    os.remove('somefile.tmp')
    print("如果文件存在，已被删除")

# 相当于
try:
    os.remove('somefile.tmp')
    print("如果文件存在，已被删除")
except FileNotFoundError:
    pass
```



##### 2.4.8.2 `redirect_stdout` - 重定向标准输出

```python
from contextlib import redirect_stdout
import io

# 将输出重定向到字符串
f = io.StringIO()
with redirect_stdout(f):
    print("这不会显示在控制台")
    print("而是被重定向到字符串缓冲区")

print(f"捕获的输出: {f.getvalue()}")
```



##### 2.4.8.3 `chdir` - 临时改变工作目录

```python
from contextlib import chdir
import os

print(f"当前目录: {os.getcwd()}")
with chdir('/tmp'):
    print(f"临时目录: {os.getcwd()}")
print(f"恢复后的目录: {os.getcwd()}")
```



#### 2.4.9 异步上下文管理器

Python 3.5+ 支持异步上下文管理器：

```python
import asyncio

class AsyncConnection:
    async def __aenter__(self):
        print("异步连接建立中...")
        await asyncio.sleep(1)
        self.connection = "异步连接"
        return self
    
    async def __aexit__(self, exc_type, exc_value, traceback):
        print("异步连接关闭中...")
        await asyncio.sleep(0.5)
        self.connection = None

async def main():
    async with AsyncConnection() as conn:
        print(f"使用: {conn.connection}")

# 运行
# asyncio.run(main())
```



**最佳实践**

1. **总是使用上下文管理器**管理需要清理的资源
2. **在 `__exit__` 方法中正确处理异常**
3. **使用 `contextmanager` 装饰器简化实现**
4. **考虑使用 `ExitStack` 管理多个上下文**
5. **为资源管理创建专用的上下文管理器**

上下文管理器是Python中优雅管理资源的强大工具，它们使代码更加清晰、安全，并减少了资源泄漏的风险。





### 2.5 读写二进制文件

> 二进制文件读写用于处理非文本文件，如图片、音频、视频、可执行文件等。

读写二进制文件跟读写文本文件的操作类似，但是需要注意，在使用`open`函数打开文件时，如果要进行读操作，操作模式是`'rb'`，如果要进行写操作，操作模式是`'wb'`。还有一点，读写文本文件时，`read`方法的返回值以及`write`方法的参数是`str`对象（字符串），而读写二进制文件时，`read`方法的返回值以及`write`方法的参数是`bytes-like`对象（字节串）。下面的代码实现了将当前路径下名为`guido.jpg`的图片文件复制到`吉多.jpg`文件中的操作。

~~~python
try:
    with open('guido.jpg', 'rb') as file1:
        data = file1.read()
    with open('吉多.jpg', 'wb') as file2:
        file2.write(data)
except FileNotFoundError:
    print('指定的文件无法打开.')
except IOError:
    print('读写文件时出现错误.')
print('程序执行结束.')
~~~



如果要复制的图片文件很大，一次将文件内容直接读入内存中可能会造成非常大的内存开销，为了减少对内存的占用，可以为`read`方法传入`size`参数来指定每次读取的字节数，通过循环读取和写入的方式来完成上面的操作，代码如下所示。

~~~python
try:
    with open('guido.jpg', 'rb') as file1, open('吉多.jpg', 'wb') as file2:
        data = file1.read(512)
        while data:
            file2.write(data)
            data = file1.read()
except FileNotFoundError:
    print('指定的文件无法打开.')
except IOError:
    print('读写文件时出现错误.')
print('程序执行结束.')
~~~



#### 2.5.1 基本二进制文件操作

##### 2.5.1.1 打开二进制文件

使用 `'b'` 模式来指定二进制模式：

```python
# 读取二进制文件
with open('image.jpg', 'rb') as file:
    binary_data = file.read()

# 写入二进制文件
with open('copy.jpg', 'wb') as file:
    file.write(binary_data)
```



##### 2.5.1.2 基本读写方法

```python
# 读取整个文件
with open('file.bin', 'rb') as f:
    data = f.read()
    print(f"文件大小: {len(data)} 字节")

# 分块读取大文件
def read_large_binary_file(filename, chunk_size=8192):
    with open(filename, 'rb') as f:
        while True:
            chunk = f.read(chunk_size)
            if not chunk:
                break
            # 处理每个块
            process_chunk(chunk)

# 写入二进制数据
binary_data = b'\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64'  # "Hello World" 的字节表示
with open('binary_file.bin', 'wb') as f:
    f.write(binary_data)
```



#### 2.5.2 处理特定类型的二进制文件

##### 2.5.2.1 图片文件处理

```python
def copy_image(source_path, target_path):
    """复制图片文件"""
    try:
        with open(source_path, 'rb') as source:
            with open(target_path, 'wb') as target:
                # 分块复制，适合大文件
                chunk_size = 4096
                while True:
                    chunk = source.read(chunk_size)
                    if not chunk:
                        break
                    target.write(chunk)
        print(f"图片已从 {source_path} 复制到 {target_path}")
    except FileNotFoundError:
        print("文件未找到")
    except Exception as e:
        print(f"处理图片时出错: {e}")

# 使用
copy_image('photo.jpg', 'photo_copy.jpg')
```



##### 2.5.2.2 使用 `struct` 模块处理结构化二进制数据

```python
import struct

def write_student_records(filename):
    """写入结构化的学生记录"""
    students = [
        (b"Alice", 20, 85.5),  # (姓名, 年龄, 分数)
        (b"Bob", 21, 92.0),
        (b"Charlie", 19, 78.5)
    ]
    
    with open(filename, 'wb') as f:
        for name, age, score in students:
            # 格式字符串: 5s(5字节字符串) i(整数) f(浮点数)
            packed_data = struct.pack('5s i f', name, age, score)
            f.write(packed_data)

def read_student_records(filename):
    """读取结构化的学生记录"""
    records = []
    with open(filename, 'rb') as f:
        while True:
            # 读取固定大小的数据块
            data = f.read(struct.calcsize('5s i f'))
            if not data:
                break
            # 解包数据
            name, age, score = struct.unpack('5s i f', data)
            records.append((name.decode('utf-8').strip(), age, score))
    
    return records

# 使用
write_student_records('students.dat')
students = read_student_records('students.dat')
for name, age, score in students:
    print(f"姓名: {name}, 年龄: {age}, 分数: {score}")
```



#### 2.5.3 二进制文件位置操作

```python
def binary_file_operations():
    """演示二进制文件的位置操作"""
    # 创建测试文件
    with open('test.bin', 'wb') as f:
        f.write(b'0123456789ABCDEF')
    
    with open('test.bin', 'rb') as f:
        # 读取前5个字节
        data1 = f.read(5)
        print(f"前5个字节: {data1}")  # b'01234'
        
        # 获取当前位置
        position = f.tell()
        print(f"当前位置: {position}")  # 5
        
        # 移动到文件开头
        f.seek(0)
        print(f"移动后位置: {f.tell()}")  # 0
        
        # 移动到第10个字节
        f.seek(10)
        data2 = f.read(3)
        print(f"从位置10读取3个字节: {data2}")  # b'ABC'
        
        # 从当前位置向后移动2个字节
        f.seek(2, 1)  # 1 表示从当前位置
        data3 = f.read(2)
        print(f"移动后读取: {data3}")  # b'EF'
        
        # 从文件末尾向前移动5个字节
        f.seek(-5, 2)  # 2 表示从文件末尾
        data4 = f.read(3)
        print(f"从末尾读取: {data4}")  # b'BCD'

binary_file_operations()
```



#### 2.5.4 处理大文件的实用函数

```python
def compare_binary_files(file1, file2, chunk_size=8192):
    """比较两个二进制文件是否相同"""
    try:
        with open(file1, 'rb') as f1, open(file2, 'rb') as f2:
            while True:
                chunk1 = f1.read(chunk_size)
                chunk2 = f2.read(chunk_size)
                
                if chunk1 != chunk2:
                    return False
                
                if not chunk1:  # 两个文件都读取完毕
                    return True
    except FileNotFoundError:
        return False

def find_in_binary_file(filename, search_bytes, chunk_size=8192):
    """在二进制文件中搜索特定字节序列"""
    positions = []
    current_pos = 0
    
    with open(filename, 'rb') as f:
        while True:
            chunk = f.read(chunk_size)
            if not chunk:
                break
            
            # 在当前块中搜索
            index = 0
            while True:
                index = chunk.find(search_bytes, index)
                if index == -1:
                    break
                positions.append(current_pos + index)
                index += 1
            
            current_pos += len(chunk)
    
    return positions

# 使用示例
if compare_binary_files('file1.bin', 'file2.bin'):
    print("文件相同")
else:
    print("文件不同")

# 搜索特定字节
positions = find_in_binary_file('data.bin', b'\x48\x65\x6c\x6c\x6f')  # 搜索 "Hello"
print(f"找到匹配位置: {positions}")
```



#### 2.5.5 处理特定文件格式

##### 2.5.5.1 简单的 BMP 文件头读取

```python
def read_bmp_header(filename):
    """读取BMP文件头信息"""
    with open(filename, 'rb') as f:
        # 读取文件头 (14字节)
        file_header = f.read(14)
        # 读取信息头 (40字节)
        info_header = f.read(40)
        
        # 解析文件头
        signature = file_header[0:2]
        file_size = struct.unpack('<I', file_header[2:6])[0]  # 小端序
        
        # 解析信息头
        width = struct.unpack('<I', info_header[4:8])[0]
        height = struct.unpack('<I', info_header[8:12])[0]
        bits_per_pixel = struct.unpack('<H', info_header[14:16])[0]
        
        return {
            'signature': signature,
            'file_size': file_size,
            'width': width,
            'height': height,
            'bits_per_pixel': bits_per_pixel
        }

# 使用
try:
    header_info = read_bmp_header('image.bmp')
    print("BMP文件信息:")
    for key, value in header_info.items():
        print(f"  {key}: {value}")
except Exception as e:
    print(f"读取BMP文件失败: {e}")
```



#### 2.5.6 二进制数据与基本类型的转换

```
def basic_type_to_binary():
    """基本数据类型与二进制的转换"""
    
    # 整数转二进制
    number = 12345
    binary_int = number.to_bytes(4, byteorder='big')  # 4字节，大端序
    print(f"整数 {number} 的二进制表示: {binary_int}")
    
    # 二进制转整数
    restored_int = int.from_bytes(binary_int, byteorder='big')
    print(f"恢复的整数: {restored_int}")
    
    # 浮点数使用 struct
    pi = 3.14159
    binary_float = struct.pack('f', pi)
    restored_float = struct.unpack('f', binary_float)[0]
    print(f"原始浮点数: {pi}, 恢复的浮点数: {restored_float}")

basic_type_to_binary()
```



#### 2.5.7 异常处理与最佳实践

```python
class BinaryFileHandler:
    """二进制文件处理类，包含完整的异常处理"""
    
    @staticmethod
    def safe_binary_read(filename):
        """安全读取二进制文件"""
        try:
            with open(filename, 'rb') as f:
                return f.read()
        except FileNotFoundError:
            print(f"文件未找到: {filename}")
            return None
        except PermissionError:
            print(f"没有权限读取文件: {filename}")
            return None
        except Exception as e:
            print(f"读取文件时发生错误: {e}")
            return None
    
    @staticmethod
    def safe_binary_write(filename, data):
        """安全写入二进制文件"""
        try:
            with open(filename, 'wb') as f:
                f.write(data)
            print(f"数据已写入: {filename}")
            return True
        except PermissionError:
            print(f"没有权限写入文件: {filename}")
            return False
        except Exception as e:
            print(f"写入文件时发生错误: {e}")
            return False
    
    @staticmethod
    def create_test_binary_file(filename, size_in_kb=1):
        """创建测试用的二进制文件"""
        import random
        
        # 生成随机字节数据
        data = bytes(random.getrandbits(8) for _ in range(size_in_kb * 1024))
        
        with open(filename, 'wb') as f:
            f.write(data)
        print(f"已创建测试文件: {filename} ({size_in_kb}KB)")

# 使用示例
if __name__ == "__main__":
    # 创建测试文件
    BinaryFileHandler.create_test_binary_file('test_data.bin', 2)
    
    # 读取文件
    data = BinaryFileHandler.safe_binary_read('test_data.bin')
    if data:
        print(f"读取到 {len(data)} 字节数据")
        
        # 修改并保存
        modified_data = data + b'\x00\xFF\x00\xFF'
        BinaryFileHandler.safe_binary_write('modified_data.bin', modified_data)
```



#### 2.5.8 性能优化技巧

```python
def efficient_binary_operations():
    """高效的二进制文件操作技巧"""
    
    # 1. 使用适当的块大小
    def efficient_copy(source, target, chunk_size=64*1024):  # 64KB 块
        with open(source, 'rb') as src, open(target, 'wb') as tgt:
            while True:
                chunk = src.read(chunk_size)
                if not chunk:
                    break
                tgt.write(chunk)
    
    # 2. 使用内存映射处理大文件
    def memory_mapped_read(filename):
        import mmap
        with open(filename, 'rb') as f:
            with mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) as mm:
                # 可以直接在内存中访问文件内容
                return mm[:100]  # 读取前100字节
    
    # 3. 批量处理小文件
    def process_multiple_binary_files(file_list, operation):
        for filename in file_list:
            try:
                with open(filename, 'rb') as f:
                    data = f.read()
                    operation(data, filename)
            except Exception as e:
                print(f"处理文件 {filename} 时出错: {e}")

efficient_binary_operations()
```



**最佳实践总结**

1. **总是使用二进制模式**处理非文本文件
2. **使用适当的块大小**处理大文件
3. **正确处理字节序**（大端序/小端序）
4. **使用 `struct` 模块**处理结构化二进制数据
5. **实现完整的异常处理**
6. **考虑使用内存映射**处理非常大的文件
7. **测试边界情况**，特别是文件末尾和空文件

二进制文件读写是处理多媒体文件、数据序列化、网络通信等场景的基础技能，掌握这些技巧对于进行底层数据处理非常重要。









### 2.6 综合示例

```python
def read_and_process_file(filename):
    """读取并处理文件，包含完整的异常处理"""
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            lines = file.readlines()
            
        # 处理文件内容
        processed_lines = []
        for i, line in enumerate(lines, 1):
            try:
                # 假设我们要处理每行的数字
                numbers = [int(x) for x in line.strip().split()]
                processed_lines.append((i, numbers, sum(numbers)))
            except ValueError as e:
                print(f"第 {i} 行包含非数字内容: {line.strip()}")
                processed_lines.append((i, line.strip(), "处理失败"))
        
        return processed_lines
        
    except FileNotFoundError:
        print(f"错误: 文件 '{filename}' 不存在")
        return None
    except PermissionError:
        print(f"错误: 没有权限读取文件 '{filename}'")
        return None
    except Exception as e:
        print(f"未知错误: {e}")
        return None

def write_results(filename, data):
    """将处理结果写入文件"""
    try:
        with open(filename, 'w', encoding='utf-8') as file:
            for line_num, content, result in data:
                file.write(f"第 {line_num} 行: {content} -> 结果: {result}\n")
        print(f"结果已写入 {filename}")
    except Exception as e:
        print(f"写入文件时出错: {e}")

# 使用示例
if __name__ == "__main__":
    input_file = "data.txt"
    output_file = "results.txt"
    
    # 创建示例文件
    with open(input_file, 'w') as f:
        f.write("1 2 3 4 5\n")
        f.write("10 20 30\n")
        f.write("a b c\n")  # 这行会引发错误
        f.write("5 10 15 20\n")
    
    # 处理文件
    results = read_and_process_file(input_file)
    if results:
        write_results(output_file, results)
```



### 2.7 最佳实践

1. **总是使用 with 语句**处理文件，确保资源正确释放
2. **明确指定文件编码**，避免编码问题
3. **处理具体的异常类型**，而不是捕获所有异常
4. **提供有意义的错误信息**，便于调试
5. **在 finally 块中清理资源**，或使用上下文管理器
6. **考虑文件不存在的情况**，做好错误处理



### 2.8 常用文件操作函数

```python
import os

# 检查文件是否存在
if os.path.exists('file.txt'):
    print("文件存在")

# 获取文件大小
size = os.path.getsize('file.txt')

# 重命名文件
os.rename('old.txt', 'new.txt')

# 删除文件
os.remove('file.txt')
```
