## 第一部分：直接使用自定义异常

python

```
class CustomError(Exception):
    """自定义异常类"""
    def __init__(self, message, error_code=None, details=None):
        self.message = message
        self.error_code = error_code
        self.details = details
        super().__init__(self.message)
    
    def __str__(self):
        """自定义异常显示格式"""
        if self.error_code:
            return f"[Error {self.error_code}] {self.message}"
        return self.message
    
    def get_details(self):
        """获取错误详情"""
        return self.details or "无额外详情"

# 使用示例函数
def validate_age(age):
    """验证年龄"""
    if not isinstance(age, int):
        raise CustomError("年龄必须是整数", "INVALID_TYPE", {"input": age, "expected": "int"})
    if age < 0:
        raise CustomError("年龄不能为负数", "NEGATIVE_AGE", {"input": age})
    if age > 150:
        raise CustomError("年龄超出合理范围", "AGE_TOO_HIGH", {"input": age, "max_allowed": 150})
    return age

def process_user_data(user_data):
    """处理用户数据"""
    try:
        name = user_data.get('name', '未知')
        age = user_data.get('age')
        
        print(f"处理用户: {name}")
        validated_age = validate_age(age)
        print(f"年龄验证通过: {validated_age}")
        
    except CustomError as e:
        print(f"捕获自定义错误: {e}")
        print(f"错误详情: {e.get_details()}")
        # 可以根据错误代码进行不同的处理
        if e.error_code == "INVALID_TYPE":
            print("请检查输入数据类型")
        elif e.error_code == "NEGATIVE_AGE":
            print("年龄应该大于等于0")
        elif e.error_code == "AGE_TOO_HIGH":
            print("请输入合理的年龄")
    except Exception as e:
        print(f"捕获其他错误: {e}")

# 测试不同的场景
print("=== 第一部分：直接使用自定义异常 ===")

# 测试用例
test_cases = [
    {'name': '张三', 'age': 25},      # 正常情况
    {'name': '李四', 'age': -5},      # 负数年龄
    {'name': '王五', 'age': 200},     # 年龄过大
    {'name': '赵六', 'age': "二十"},  # 错误类型
]

print("--- 测试年龄验证功能 ---")
for i, user_data in enumerate(test_cases, 1):
    print(f"\n测试案例 {i}:")
    try:
        process_user_data(user_data)
    except Exception as e:
        print(f"处理过程中发生错误: {e}")

print("\n--- 直接创建自定义异常 ---")
# 直接使用自定义异常
try:
    raise CustomError("这是一个自定义错误", "CUSTOM_001", {"timestamp": "2024-01-01", "module": "test"})
except CustomError as e:
    print(f"错误信息: {e}")
    print(f"错误代码: {e.error_code}")
    print(f"错误详情: {e.get_details()}")
```



## 第二部分：使用继承的自定义异常

python

```
class CustomError(Exception):
    """基础自定义异常类"""
    def __init__(self, message, error_code=None, details=None):
        self.message = message
        self.error_code = error_code
        self.details = details
        super().__init__(self.message)
    
    def __str__(self):
        """自定义异常显示格式"""
        if self.error_code:
            return f"[Error {self.error_code}] {self.message}"
        return self.message
    
    def get_details(self):
        """获取错误详情"""
        return self.details or "无额外详情"

# 继承自定义异常创建更具体的异常
class DatabaseError(CustomError):
    """数据库相关异常"""
    def __init__(self, message, query=None, db_type="MySQL"):
        super().__init__(message, "DB_ERROR", {"query": query, "database": db_type})

class NetworkError(CustomError):
    """网络相关异常"""
    def __init__(self, message, url=None, status_code=None):
        super().__init__(message, "NETWORK_ERROR", {"url": url, "status_code": status_code})

class FileSystemError(CustomError):
    """文件系统相关异常"""
    def __init__(self, message, file_path=None, operation=None):
        super().__init__(message, "FILE_ERROR", {"file_path": file_path, "operation": operation})

# 使用继承异常的专业函数
def connect_to_database(connection_string):
    """模拟数据库连接"""
    if "mysql" not in connection_string:
        raise DatabaseError("不支持的数据库类型", f"CONNECT TO {connection_string}", "MySQL")
    print(f"成功连接到数据库: {connection_string}")

def make_http_request(url):
    """模拟HTTP请求"""
    if "timeout" in url:
        raise NetworkError("请求超时", url, 408)
    elif "404" in url:
        raise NetworkError("页面未找到", url, 404)
    print(f"成功请求: {url}")

def read_file(file_path):
    """模拟文件读取"""
    if not file_path.endswith('.txt'):
        raise FileSystemError("不支持的文件格式", file_path, "read")
    print(f"成功读取文件: {file_path}")

print("=== 第二部分：使用继承的自定义异常 ===")

print("\n--- 测试数据库异常 ---")
try:
    connect_to_database("postgresql://localhost:5432")
except DatabaseError as e:
    print(f"数据库错误: {e}")
    print(f"详情: {e.get_details()}")

print("\n--- 测试网络异常 ---")
try:
    make_http_request("https://api.example.com/timeout")
except NetworkError as e:
    print(f"网络错误: {e}")
    print(f"状态码: {e.details.get('status_code')}")
    print(f"请求URL: {e.details.get('url')}")

print("\n--- 测试文件系统异常 ---")
try:
    read_file("data.pdf")
except FileSystemError as e:
    print(f"文件系统错误: {e}")
    print(f"操作类型: {e.details.get('operation')}")
    print(f"文件路径: {e.details.get('file_path')}")

print("\n--- 成功案例 ---")
try:
    connect_to_database("mysql://localhost:3306")
    make_http_request("https://api.example.com/data")
    read_file("data.txt")
    print("所有操作成功完成！")
except (DatabaseError, NetworkError, FileSystemError) as e:
    print(f"操作失败: {e}")
```



## 分离后的优势：

1. **第一部分**：专注于基础自定义异常的使用，适合初学者理解
2. **第二部分**：展示异常继承和专业化，适合进阶学习
3. **独立运行**：每个部分都可以单独运行和测试
4. **清晰分层**：从基础到高级，循序渐进
