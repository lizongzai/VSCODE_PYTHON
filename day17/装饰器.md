# 装饰器


## 第一部分：
Python 语言中，装饰器是“**用一个函数装饰另外一个函数并为其提供额外的能力**”的语法现象。装饰器本身是一个函数，它的参数是被装饰的函数，它的返回值是一个带有装饰功能的函数。通过前面的描述，相信大家已经听出来了，装饰器是一个高阶函数，它的参数和返回值都是函数。但是，装饰器的概念对编程语言的初学者来说，还是让人头疼的，下面我们先通过一个简单的例子来说明装饰器的作用。假设有名为`downlaod`和`upload`的两个函数，分别用于文件的上传和下载，如下所示。

~~~python
import random
import time


def download(filename):
    """下载文件"""
    print(f'开始下载{filename}.')
    time.sleep(random.random() * 6)
    print(f'{filename}下载完成.')

    
def upload(filename):
    """上传文件"""
    print(f'开始上传{filename}.')
    time.sleep(random.random() * 8)
    print(f'{filename}上传完成.')

    
download('MySQL从删库到跑路.avi')
upload('Python从入门到住院.pdf')
~~~



> **说明**：上面的代码用休眠一段随机时间的方式模拟了下载和上传文件需要花费一定的时间，并没有真正的联网上传下载文件。用 Python 语言实现联网上传下载文件也非常简单，后面我们会讲到相关的知识。



现在有一个新的需求，我们希望知道调用`download`和`upload`函数上传下载文件到底用了多少时间，这应该如何实现呢？相信很多小伙伴已经想到了，我们可以在函数开始执行的时候记录一个时间，在函数调用结束后记录一个时间，两个时间相减就可以计算出下载或上传的时间，代码如下所示。

~~~python
start = time.time()
download('MySQL从删库到跑路.avi')
end = time.time()
print(f'花费时间: {end - start:.2f}秒')

start = time.time()
upload('Python从入门到住院.pdf')
end = time.time()
print(f'花费时间: {end - start:.2f}秒')
~~~



通过上面的代码，我们可以在下载和上传文件时记录下耗费的时间，但不知道大家是否注意到，上面记录时间、计算和显示执行时间的代码都是重复代码。有编程经验的人都知道，**重复的代码是万恶之源**，那么有没有办法在不写重复代码的前提下，用一种简单优雅的方式记录下函数的执行时间呢？在 Python 语言中，装饰器就是解决这类问题的最佳选择。通过装饰器语法，我们可以把跟原来的业务（上传和下载）没有关系计时功能的代码封装到一个函数中，如果`upload`和`download`函数需要记录时间，我们直接把装饰器作用到这两个函数上即可。既然上面提到了，装饰器是一个高阶函数，它的参数和返回值都是函数，我们将记录时间的装饰器姑且命名为`record_time`，那么它的整体结构应该如下面的代码所示。

~~~python
def record_time(func):
    
    def wrapper(*args, **kwargs):
        
        result = func(*args, **kwargs)
        
        return result
    
    return wrapper
~~~



相信大家注意到了，`record_time`函数的参数`func`代表了一个被装饰的函数，函数里面定义的`wrapper`函数是带有装饰功能的函数，它会执行被装饰的函数`func`，它还需要返回在最后产生函数执行的返回值。不知大家是否留意到，上面的代码我在第4行和第6行留下了两个空行，这意味着我们可以这些地方添加代码来实现额外的功能。`record_time`函数最终会返回这个带有装饰功能的函数`wrapper`并通过它替代原函数`func`，当原函数`func`被`record_time`函数装饰后，我们调用它时其实调用的是`wrapper`函数，所以才获得了额外的能力。`wrapper`函数的参数比较特殊，由于我们要用`wrapper`替代原函数`func`，但是我们又不清楚原函数`func`会接受哪些参数，所以我们就通过可变参数和关键字参数照单全收，然后在调用`func`的时候，原封不动的全部给它。这里还要强调一下，Python 语言支持函数的嵌套定义，就像上面，我们可以在`record_time`函数中定义`wrapper`函数，这个操作在很多编程语言中并不被支持。

看懂这个结构后，我们就可以把记录时间的功能写到这个装饰器中，代码如下所示。

~~~python
import time


def record_time(func):

    def wrapper(*args, **kwargs):
        # 在执行被装饰的函数之前记录开始时间
        start = time.time()
        # 执行被装饰的函数并获取返回值
        result = func(*args, **kwargs)
        # 在执行被装饰的函数之后记录结束时间
        end = time.time()
        # 计算和显示被装饰函数的执行时间
        print(f'{func.__name__}执行时间: {end - start:.2f}秒')
        # 返回被装饰函数的返回值
        return result
    
    return wrapper
~~~



写装饰器虽然颇费周折，但是这是个一劳永逸的骚操作，将来再有记录函数执行时间的需求时，我们只需要添加上面的装饰器即可。使用上面的装饰器函数有两种方式，第一种方式就是直接调用装饰器函数，传入被装饰的函数并获得返回值，我们可以用这个返回值直接替代原来的函数，那么在调用时就已经获得了装饰器提供的额外的能力（记录执行时间），大家试试下面的代码就明白了。



~~~python
download = record_time(download)
upload = record_time(upload)
download('MySQL从删库到跑路.avi')
upload('Python从入门到住院.pdf')
~~~





在 Python 中，使用装饰器很有更为便捷的**语法糖**（编程语言中添加的某种语法，这种语法对语言的功能没有影响，但是使用更加方法，代码的可读性也更强，我们将其称之为“语法糖”或“糖衣语法”），可以用`@装饰器函数`将装饰器函数直接放在被装饰的函数上，效果跟上面的代码相同。我们把完整的代码为大家罗列出来，大家可以再看看我们是如何定义和使用装饰器的。

~~~python
import random
import time


def record_time(func):

    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'{func.__name__}执行时间: {end - start:.2f}秒')
        return result

    return wrapper


@record_time
def download(filename):
    print(f'开始下载{filename}.')
    time.sleep(random.random() * 6)
    print(f'{filename}下载完成.')


@record_time
def upload(filename):
    print(f'开始上传{filename}.')
    time.sleep(random.random() * 8)
    print(f'{filename}上传完成.')


download('MySQL从删库到跑路.avi')
upload('Python从入门到住院.pdf')
~~~



上面的代码，我们通过装饰器语法糖为`download`和`upload`函数添加了装饰器，被装饰后的`download`和`upload`函数其实就是我们在装饰器中返回的`wrapper`函数，调用它们其实就是在调用`wrapper`函数，所以才有了记录函数执行时间的功能。

如果在代码的某些地方，我们想去掉装饰器的作用执行原函数，那么在定义装饰器函数的时候，需要做一点点额外的工作。Python 标准库`functools`模块的`wraps`函数也是一个装饰器，我们将它放在`wrapper`函数上，这个装饰器可以帮我们保留被装饰之前的函数，这样在需要取消装饰器时，可以通过被装饰函数的`__wrapped__`属性获得被装饰之前的函数。

~~~python
import random
import time

from functools import wraps


def record_time(func):

    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'{func.__name__}执行时间: {end - start:.2f}秒')
        return result

    return wrapper


@record_time
def download(filename):
    print(f'开始下载{filename}.')
    time.sleep(random.random() * 6)
    print(f'{filename}下载完成.')


@record_time
def upload(filename):
    print(f'开始上传{filename}.')
    time.sleep(random.random() * 8)
    print(f'{filename}上传完成.')


# 调用装饰后的函数会记录执行时间
download('MySQL从删库到跑路.avi')
upload('Python从入门到住院.pdf')
# 取消装饰器的作用不记录执行时间
download.__wrapped__('MySQL必知必会.pdf')
upload.__wrapped__('Python从新手到大师.pdf')
~~~



**装饰器函数本身也可以参数化**，简单的说就是装饰器也是可以通过调用者传入的参数来进行定制的，这个知识点我们在后面用到的时候再为大家讲解。




## 第二部分： 举例装饰器

~~~python
# 导入模块
import time
from functools import wraps

# 装饰器定义
def timer(func):
    
    # 使用wraps装饰器
    @wraps(func)
    
    # 定义包装函数
    def wrapper(*args, **kwargs):
        # 记录开始时间
        start_time = time.time()
        
        # 执行原函数
        result = func(*args, **kwargs)
        
        # 记录结束时间
        end_time = time.time()
        
        # 计算执行时间
        execution_time = end_time - start_time
        
        # 输出执行时间
        print(f"函数 {func.__name__} 执行耗时: {execution_time:.4f} 秒")
        
        # 返回原函数的执行结果，确保装饰器不会改变函数的返回值
        return result
    
    # 返回内部函数`wrapper`，这个函数将替代原函数
    return wrapper

# 使用装饰器
@timer
def download(file_path):
    """模拟下载文件"""
    print(f"开始下载文件: {file_path}")
    time.sleep(2)  # 模拟下载耗时
    print("下载完成")
    return f"下载文件: {file_path}"

@timer
def upload(file_path):
    """模拟上传文件"""
    print(f"开始上传文件: {file_path}")
    time.sleep(1.5)  # 模拟上传耗时
    print("上传完成")
    return f"上传文件: {file_path}"

# 测试
if __name__ == "__main__":
    download("example.txt")
    upload("example.txt")
~~~




## 第三部分：代码逐行解释

### 1.导入模块

```python
import time
from functools import wraps
```

- `import time`: 导入时间模块，用于获取当前时间戳

- `from functools import wraps`: 导入wraps装饰器，用于保留原函数的元信息

  

### 2. 装饰器定义

```python
def timer(func):
```

- 定义装饰器函数`timer`，它接受一个函数`func`作为参数



### 3. 使用wraps装饰器

```python
    @wraps(func)
```

- 使用`wraps`装饰器来保留原函数的名称、文档字符串等元信息
- 如果不使用`wraps`，被装饰的函数会显示为`wrapper`而不是原函数名


### 4. 定义包装函数

```python
    def wrapper(*args, **kwargs):
```

- 定义内部函数`wrapper`，它接受任意位置参数和关键字参数
- 这个函数将替代原函数执行


### 5. 记录开始时间

```python
        start_time = time.time()
```

- 调用`time.time()`获取当前时间戳，记录函数开始执行的时间



### 6. 执行原函数

```python
        result = func(*args, **kwargs)
```

- 调用原始函数`func`，并传入所有参数
- 将函数的返回值保存在`result`变量中


### 7. 记录结束时间

```python
        end_time = time.time()
```

- 再次调用`time.time()`获取当前时间戳，记录函数结束的时间



### 8. 计算执行时间

```python
        execution_time = end_time - start_time
```

- 计算结束时间与开始时间的差值，得到函数执行的总时间



### 9. 输出执行时间

```python
        print(f"函数 {func.__name__} 执行耗时: {execution_time:.4f} 秒")
```

- 打印函数名称和执行时间，`.4f`表示保留4位小数

### 10. 返回结果

```python
        return result
```

- 返回原函数的执行结果，确保装饰器不会改变函数的返回值



### 11. 返回包装函数

```python
    return wrapper
```

- 返回内部函数`wrapper`，这个函数将替代原函数



## 第三部分：装饰器使用部分

### 12. 应用装饰器

```
@timer
def download(file_path):
```

- `@timer`语法糖相当于：`download = timer(download)`
- 将`download`函数传递给`timer`装饰器，返回新的`wrapper`函数



### 13. 原函数定义

```
    """模拟下载文件"""
    print(f"开始下载文件: {file_path}")
    time.sleep(2)  # 模拟下载耗时
    print("下载完成")
    return f"下载文件: {file_path}"
```

- 这是原始的`download`函数实现





## 第四部分： 调度过程详解

**当调用 `download("example.txt")` 时：**

### 1. **装饰阶段**（程序加载时）：

   ```python
   download = timer(download)
   ```

   - `timer(download)` 执行，返回 `wrapper` 函数
   - 现在 `download` 变量指向的是 `wrapper` 函数

   

### 2. **调用阶段**（运行时）：

   ```python
   download("example.txt")
   ```

   

   实际执行的是：

   ```python
   wrapper("example.txt")
   ```

   

### 3. **wrapper函数内部执行流程**：

   ```python
   start_time = time.time()                    # 记录开始时间
   result = func("example.txt")               # 调用原始download函数
   # 在原始download函数内部：
   #   print("开始下载文件: example.txt")
   #   time.sleep(2)
   #   print("下载完成")
   #   return "下载文件: example.txt"
   end_time = time.time()                     # 记录结束时间
   execution_time = end_time - start_time     # 计算耗时
   print(f"函数 download 执行耗时: {execution_time:.4f} 秒")  # 输出耗时
   return result                              # 返回原函数结果
   ```

   

执行结果：

```
开始下载文件: example.txt
下载完成
函数 download 执行耗时: 2.0012 秒
开始上传文件: example.txt
上传完成
函数 upload 执行耗时: 1.5008 秒
```


## 第四部分：关键点总结

1. **装饰时机**：装饰发生在模块导入时，不是在函数调用时
2. **函数替换**：原函数被替换为包装函数
3. **参数传递**：`*args, **kwargs`确保所有参数都能正确传递
4. **返回值保持**：包装函数返回原函数的返回值
5. **元信息保留**：`@wraps(func)`确保函数名、文档等元信息不被丢失





##### 2.5.4.5 总结

装饰器是 Python 语言中的特色语法，**可以通过装饰器来增强现有的函数**，这是一种非常有用的编程技巧。另一方面，通过函数递归调用，可以在代码层面将一些复杂的问题简单化，但是**递归调用一定要注意收敛条件和递归公式**，找到递归公式才有机会使用递归调用，而收敛条件则确保了递归调用能停下来。函数调用通过内存中的栈空间来保存现场和恢复现场，栈空间通常都很小，所以**递归如果不能迅速收敛，很可能会引发栈溢出错误，从而导致程序的崩溃**。













































