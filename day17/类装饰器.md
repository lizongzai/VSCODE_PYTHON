# 类装饰器

~~~python
"""
Version: 1.0
Author: 李小婕
Date: 2025-10-19
Decription: 类装饰器

Keyword arguments:
argument -- description
Return: return_description
"""

import time
from functools import wraps

class Timer:
    """计时器类装饰器"""
    
    def __init__(self, func):
        self.func = func
        wraps(func)(self)
    
    def __call__(self, *args, **kwargs):
        start_time = time.time()
        result = self.func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        
        print(f"⏰ 函数 {self.func.__name__} 执行耗时: {execution_time:.4f} 秒")
        return result

# 使用类装饰器
@Timer
def download(file_path):
    print(f"开始下载文件: {file_path}")
    time.sleep(2)
    print("下载完成")
    return f"下载文件: {file_path}"

@Timer
def upload(file_path):
    print(f"开始上传文件: {file_path}")
    time.sleep(1.5)
    print("上传完成")
    return f"上传文件: {file_path}"


# 测试
if __name__ == "__main__":
    download("example.txt")
    upload("example.txt")
~~~





## 代码逐行解释

### 1. 导入模块

```
import time
from functools import wraps
```



### 2. 类装饰器定义

```
class Timer:
    """计时器类装饰器"""
```



- 定义一个类`Timer`作为装饰器
- 类装饰器通过实现特殊方法来实现装饰功能

### 3. 初始化方法

```
    def __init__(self, func):
        self.func = func
        wraps(func)(self)
```



- `__init__`方法在装饰时调用，接受被装饰的函数`func`
- `self.func = func`：将原函数保存为实例属性
- `wraps(func)(self)`：将原函数的元信息复制到类实例中

### 4. 调用方法

```
    def __call__(self, *args, **kwargs):
```



- `__call__`方法使类实例可以像函数一样被调用
- 当调用被装饰的函数时，实际上调用的是这个`__call__`方法

### 5. 计时逻辑

```
        start_time = time.time()
        result = self.func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
```



- 记录开始时间
- 调用原始函数（通过`self.func`访问）
- 记录结束时间并计算执行时间

### 6. 输出结果

```
        print(f"⏰ 函数 {self.func.__name__} 执行耗时: {execution_time:.4f} 秒")
        return result
```



- 输出带表情符号的计时信息
- 返回原函数的执行结果

## 调度过程详解

### 阶段1：装饰阶段（程序加载时）

当Python解释器执行到`@Timer`时：

```
# 对于 @Timer
def download(file_path):
    ...

# 实际执行：download = Timer(download)
```



**详细步骤：**

1. 定义`download`函数
2. 创建`Timer`类的实例：`timer_instance = Timer(download)`
3. 在`__init__`方法中：
   - `self.func = download`（保存原函数）
   - `wraps(download)(self)`（复制元信息）
4. `download`变量现在指向`timer_instance`（Timer类的实例）

### 阶段2：调用阶段（运行时）

当调用`download("example.txt")`时：

```
# 实际执行：timer_instance("example.txt")
# 因为download现在是Timer类的实例，所以调用__call__方法
```



**__call__方法执行流程：**

```
def __call__(self, *args, **kwargs):  # self=timer_instance, args=("example.txt",)
    start_time = time.time()
    
    # 调用原始download函数
    result = self.func(*args, **kwargs)  # self.func是原始download函数
    
    # 在原始download函数中：
    #   print("开始下载文件: example.txt")
    #   time.sleep(2)
    #   print("下载完成")
    #   return "下载文件: example.txt"
    
    end_time = time.time()
    execution_time = end_time - start_time
    
    print(f"⏰ 函数 download 执行耗时: 2.0012 秒")
    return "下载文件: example.txt"  # 返回原函数的结果
```



## 内存状态变化

### 装饰前：

- `download` → 指向函数对象

### 装饰后：

- `download` → 指向`Timer`类的实例
- `timer_instance.func` → 指向原始download函数
- `timer_instance.__name__` → "download"（通过wraps复制）

## 验证代码

我们可以添加一些调试信息来验证：

```
@Timer
def download(file_path):
    print(f"download的类型: {type(download)}")
    print(f"download是Timer实例: {isinstance(download, Timer)}")
    print(f"函数名: {download.__name__}")
    print(f"开始下载文件: {file_path}")
    time.sleep(2)
    print("下载完成")
    return f"下载文件: {file_path}"

# 测试
print("装饰前查看:")
download("example.txt")
```



输出结果：

```
装饰前查看:
download的类型: <class '__main__.Timer'>
download是Timer实例: True
函数名: download
开始下载文件: example.txt
下载完成
⏰ 函数 download 执行耗时: 2.0012 秒
```



## 类装饰器 vs 函数装饰器

### 类装饰器特点：

1. **使用类实现**：通过`__init__`和`__call__`方法
2. **状态保持**：可以更容易地维护状态（虽然这个例子中没有）
3. **更清晰的结构**：对于复杂的装饰器，类结构可能更清晰

### 函数装饰器特点：

1. **使用嵌套函数**：通过闭包机制
2. **简洁**：对于简单功能更简洁
3. **传统方式**：更常见的实现方式

## 预期输出结果

```
开始下载文件: example.txt
下载完成
⏰ 函数 download 执行耗时: 2.0012 秒
开始上传文件: example.txt
上传完成
⏰ 函数 upload 执行耗时: 1.5008 秒
```



## 关键要点

1. **类实例可调用**：通过实现`__call__`方法，类实例可以像函数一样调用
2. **装饰时机**：`__init__`在装饰时调用，`__call__`在函数调用时调用
3. **元信息保留**：使用`wraps(func)(self)`来复制函数元信息到类实例
4. **函数保存**：原始函数通过`self.func`保存在实例属性中
