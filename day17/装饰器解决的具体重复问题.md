# 问题场景：多个函数都需要相同的附加功能

**没有装饰器时的重复代码**：

python

```
def 下载文件(文件名):
    # 重复的计时代码开始
    start_time = time.time()
    print(f"开始时间: {time.strftime('%H:%M:%S')}")
    
    # 核心业务逻辑
    time.sleep(2)  # 模拟下载
    result = f"下载完成: {文件名}"
    
    # 重复的计时代码结束
    end_time = time.time()
    print(f"结束时间: {time.strftime('%H:%M:%S')}")
    print(f"耗时: {end_time - start_time:.2f}秒")
    return result

def 上传文件(文件名):
    # 重复的计时代码开始
    start_time = time.time()
    print(f"开始时间: {time.strftime('%H:%M:%S')}")
    
    # 核心业务逻辑
    time.sleep(1.5)  # 模拟上传
    result = f"上传完成: {文件名}"
    
    # 重复的计时代码结束
    end_time = time.time()
    print(f"结束时间: {time.strftime('%H:%M:%S')}")
    print(f"耗时: {end_time - start_time:.2f}秒")
    return result

def 处理文件(文件名):
    # 重复的计时代码开始
    start_time = time.time()
    print(f"开始时间: {time.strftime('%H:%M:%S')}")
    
    # 核心业务逻辑
    time.sleep(1)  # 模拟处理
    result = f"处理完成: {文件名}"
    
    # 重复的计时代码结束
    end_time = time.time()
    print(f"结束时间: {time.strftime('%H:%M:%S')}")
    print(f"耗时: {end_time - start_time:.2f}秒")
    return result
```



**问题**：计时代码在每个函数中重复了3次！

## 💡 使用装饰器消除重复

python

```
def 计时装饰器(原函数):
    def 包装函数(*args, **kwargs):
        # 计时逻辑（只写一次）
        start_time = time.time()
        print(f"开始时间: {time.strftime('%H:%M:%S')}")
        
        # 核心业务逻辑（原函数）
        结果 = 原函数(*args, **kwargs)
        
        # 计时逻辑（只写一次）
        end_time = time.time()
        print(f"结束时间: {time.strftime('%H:%M:%S')}")
        print(f"耗时: {end_time - start_time:.2f}秒")
        
        return 结果
    return 包装函数

# 使用装饰器 - 简洁多了！
@计时装饰器
def 下载文件(文件名):
    time.sleep(2)
    return f"下载完成: {文件名}"

@计时装饰器
def 上传文件(文件名):
    time.sleep(1.5)
    return f"上传完成: {文件名}"

@计时装饰器
def 处理文件(文件名):
    time.sleep(1)
    return f"处理完成: {文件名}"
```



## 🚀 装饰器解决的常见重复问题

### 1. 日志记录

python

```
def 日志装饰器(函数):
    def 包装(*args, **kwargs):
        print(f"[日志] 调用函数: {函数.__name__}, 参数: {args} {kwargs}")
        结果 = 函数(*args, **kwargs)
        print(f"[日志] 函数 {函数.__name__} 返回: {结果}")
        return 结果
    return 包装
```



### 2. 权限验证

python

```
def 登录验证(函数):
    def 包装(*args, **kwargs):
        if not 用户已登录():
            return "请先登录"
        return 函数(*args, **kwargs)
    return 包装

@登录验证
def 查看个人信息():
    return "用户个人信息"

@登录验证  
def 修改密码():
    return "密码修改成功"
```



### 3. 缓存结果

python

```
def 缓存装饰器(函数):
    缓存 = {}
    def 包装(*args):
        if args in 缓存:
            return 缓存[args]
        结果 = 函数(*args)
        缓存[args] = 结果
        return 结果
    return 包装

@缓存装饰器
def 复杂计算(x):
    time.sleep(2)  # 模拟复杂计算
    return x * x
```



## 📊 装饰器的优势对比

| 方面       | 没有装饰器   | 使用装饰器         |
| :--------- | :----------- | :----------------- |
| **代码量** | 大量重复代码 | 逻辑只写一次       |
| **维护性** | 修改要改多处 | 只需改装饰器       |
| **可读性** | 业务逻辑混杂 | 业务逻辑清晰       |
| **复用性** | 难以复用     | 轻松应用到其他函数 |

## 🎨 实际业务场景

python

```
# 电商系统中的重复横切关注点
@登录验证
@权限检查("买家")
@操作日志
@性能监控
def 下单(商品ID, 数量):
    """核心业务逻辑 - 保持纯净"""
    return f"订单创建成功: {商品ID} x {数量}"

@登录验证  
@权限检查("卖家")
@操作日志
@性能监控
def 上架商品(商品信息):
    """核心业务逻辑 - 保持纯净"""
    return f"商品上架成功: {商品信息}"
```



## 💎 总结

**装饰器主要解决**：

1. **横切关注点重复**：日志、计时、权限等多个函数都需要的功能
2. **代码冗余**：相同的辅助代码在多个地方重复出现
3. **关注点分离**：业务逻辑与辅助逻辑混杂的问题
4. **维护困难**：修改公共功能需要改动多个地方

**核心价值**：**一次编写，多处使用**，让代码更干净、更易维护！
