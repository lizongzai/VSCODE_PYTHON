# 可重用的计时器装饰器


~~~python
import time
from functools import wraps
from datetime import datetime

def advanced_timer(print_result=True, save_to_file=False):
    """高级计时装饰器，支持更多功能"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 开始计时
            start_time = time.time()
            start_datetime = datetime.now()
            
            # 执行原函数
            result = func(*args, **kwargs)
            
            # 结束计时
            end_time = time.time()
            execution_time = end_time - start_time
            
            # 输出结果
            time_info = f"""
╔══════════════════════════════════════╗
║            函数执行时间统计           ║
╠══════════════════════════════════════╣
║ 函数名称: {func.__name__:<25} ║
║ 开始时间: {start_datetime.strftime('%Y-%m-%d %H:%M:%S')} ║
║ 执行耗时: {execution_time:.6f} 秒        ║
║ 执行结果: {result if print_result else '***'} ║
╚══════════════════════════════════════╝
            """
            print(time_info)
            
            # 可选：保存到文件
            if save_to_file:
                with open('function_timing.log', 'a', encoding='utf-8') as f:
                    f.write(time_info + '\n')
            
            return result
        return wrapper
    return decorator

# 使用高级装饰器
@advanced_timer(print_result=True, save_to_file=False)
def download(file_path):
    print(f"开始下载文件: {file_path}")
    time.sleep(2)
    print("下载完成")
    return f"下载文件: {file_path}成功"

@advanced_timer(print_result=False)
def upload(file_path):
    print(f"开始上传文件: {file_path}")
    time.sleep(1.5)
    print("上传完成")
    return f"上传文件: {file_path}成功"
~~~



## 代码逐行解读

### 1. 导入模块

```
import time
from functools import wraps
from datetime import datetime
```



- `time`: 提供时间相关功能，用于测量执行时间
- `functools.wraps`: 装饰器工具，保留原函数的元信息
- `datetime`: 获取格式化的时间字符串

### 2. 装饰器定义

```
def advanced_timer(print_result=True, save_to_file=False):
```



- 定义外层装饰器函数，接受两个参数：
  - `print_result`: 是否打印函数返回值（默认True）
  - `save_to_file`: 是否保存到文件（默认False）

### 3. 内层装饰器

```
def decorator(func):
```



- 定义实际的装饰器函数，接收被装饰的函数作为参数

### 4. 使用wraps装饰器

```
@wraps(func)
def wrapper(*args, **kwargs):
```



- `@wraps(func)`: 保留原函数的名称、文档字符串等元信息
- `wrapper`: 实际的包装函数，接受任意位置和关键字参数

### 5. 计时开始

```
start_time = time.time()          # 获取开始时间戳（精确到秒）
start_datetime = datetime.now()   # 获取格式化的开始时间
```



### 6. 执行原函数

```
result = func(*args, **kwargs)    # 调用原函数并保存返回值
```



### 7. 计时结束和计算

```
end_time = time.time()            # 获取结束时间戳
execution_time = end_time - start_time  # 计算执行时间
```



### 8. 格式化输出信息

```
time_info = f"""
╔══════════════════════════════════════╗
║            函数执行时间统计           ║
╠══════════════════════════════════════╣
║ 函数名称: {func.__name__:<25} ║
║ 开始时间: {start_datetime.strftime('%Y-%m-%d %H:%M:%S')} ║
║ 执行耗时: {execution_time:.6f} 秒        ║
║ 执行结果: {result if print_result else '***'} ║
╚══════════════════════════════════════╝
"""
```



- 使用三引号创建多行字符串
- `{func.__name__:<25}`: 函数名左对齐，占25字符宽度
- `{execution_time:.6f}`: 执行时间保留6位小数
- 条件表达式控制是否显示结果

### 9. 打印信息

```
print(time_info)  # 在控制台输出计时信息
```



### 10. 可选的文件保存

```
if save_to_file:
    with open('function_timing.log', 'a', encoding='utf-8') as f:
        f.write(time_info + '\n')
```



- 如果`save_to_file`为True，以追加模式写入文件

### 11. 返回结果

```
return result  # 返回原函数的执行结果
```



### 12. 装饰器返回

```
return wrapper     # 返回包装后的函数
return decorator   # 返回装饰器函数
```



## 函数调用过程详解

### 1. 装饰器应用

```
@advanced_timer(print_result=True, save_to_file=False)
def download(file_path):
    # 函数体
```



**执行顺序：**

1. `advanced_timer(print_result=True, save_to_file=False)` 被调用
2. 返回 `decorator` 函数
3. `decorator(download)` 被调用
4. 返回 `wrapper` 函数
5. `download` 现在实际上指向 `wrapper` 函数

### 2. 函数调用过程

当调用 `download("example.txt")` 时：

1. **实际上调用的是** `wrapper("example.txt")`
2. `wrapper` 函数开始执行：
   - 记录开始时间
   - 调用原始 `download` 函数：`func(*args, **kwargs)`
   - 原始函数执行：打印信息、sleep 2秒、返回结果
   - 记录结束时间并计算耗时
   - 格式化输出信息并打印
   - 返回原始函数的结果

### 3. 具体执行流程

```
# 调用 download("example.txt")
↓
# 进入 wrapper("example.txt")
↓
start_time = time.time()                    # 记录开始时间
↓
result = download_original("example.txt")   # 执行原函数
    ↓
    print("开始下载文件: example.txt")
    ↓
    time.sleep(2)                           # 模拟下载耗时
    ↓
    print("下载完成")
    ↓
    return "下载文件: example.txt成功"       # 返回结果
↓
end_time = time.time()                      # 记录结束时间
↓
execution_time = end_time - start_time      # 计算执行时间
↓
格式化输出信息并打印
↓
return result                               # 返回下载结果
```



## 装饰器的优势

1. **代码复用**: 多个函数可以共用同一个计时逻辑
2. **非侵入式**: 不需要修改原函数代码
3. **灵活配置**: 通过参数控制不同行为
4. **保持元信息**: 使用`@wraps`保留函数原始信息
