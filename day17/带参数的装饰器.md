# 带参数的装饰器




~~~python
"""
Version: 1.0
Author: 李小婕
Date: 2025-10-19
Decription: 类装饰器

Keyword arguments:
argument -- description
Return: return_description
"""

import time
from functools import wraps

def timer(unit='seconds'):
    """带参数的装饰器，可以选择时间单位"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()
            execution_time = end_time - start_time
            
            # 根据单位转换时间
            if unit == 'milliseconds':
                execution_time *= 1000
                time_unit = "毫秒"
            elif unit == 'minutes':
                execution_time /= 60
                time_unit = "分钟"
            else:
                time_unit = "秒"
            
            print(f"函数 {func.__name__} 执行耗时: {execution_time:.4f} {time_unit}")
            return result
        return wrapper
    return decorator

# 使用带参数的装饰器
@timer(unit='milliseconds')
def download(file_path):
    print(f"开始下载文件: {file_path}")
    time.sleep(2)
    print("下载完成")
    return f"下载文件: {file_path}"

@timer(unit='seconds')
def upload(file_path):
    print(f"开始上传文件: {file_path}")
    time.sleep(1.5)
    print("上传完成")
    return f"上传文件: {file_path}"
~~~





## 代码逐行解释

### 1. 文档字符串和导入

python

```
"""
Version: 1.0
Author: 李小婕
Date: 2025-10-19
Decription: 带参数的装饰器
"""
import time
from functools import wraps
```



### 2. 带参数的装饰器定义

python

```
def timer(unit='seconds'):
```



- 定义外层函数`timer`，它接受参数`unit`（默认值为'seconds'）
- 这是一个装饰器工厂函数，返回真正的装饰器

### 3. 真正的装饰器定义

python

```
    def decorator(func):
```



- 定义内层函数`decorator`，它接受要装饰的函数`func`
- 这是实际的装饰器函数

### 4. 包装函数定义

python

```
        @wraps(func)
        def wrapper(*args, **kwargs):
```



- 使用`@wraps`保留原函数元信息
- 定义最内层的包装函数`wrapper`，它接受所有参数

### 5. 计时逻辑

python

```
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()
            execution_time = end_time - start_time
```



- 记录开始时间、执行原函数、记录结束时间、计算执行时间

### 6. 时间单位转换

python

```
            # 根据单位转换时间
            if unit == 'milliseconds':
                execution_time *= 1000
                time_unit = "毫秒"
            elif unit == 'minutes':
                execution_time /= 60
                time_unit = "分钟"
            else:
                time_unit = "秒"
```



- 根据`unit`参数转换时间单位和设置显示文本

### 7. 输出结果并返回

python

```
            print(f"函数 {func.__name__} 执行耗时: {execution_time:.4f} {time_unit}")
            return result
        return wrapper
    return decorator
```



## 调度过程详解

### 阶段1：装饰阶段（程序加载时）

#### 对于 `@timer(unit='milliseconds')`

实际执行过程：

python

```
# 等价于：download = timer(unit='milliseconds')(download)
```



**详细步骤：**

1. `timer(unit='milliseconds')` 执行，返回 `decorator` 函数
2. `decorator(download)` 执行，返回 `wrapper` 函数
3. `download` 变量现在指向 `wrapper` 函数

**内存中的闭包关系：**

- `wrapper` 函数闭包中包含：
  - `func` → 原始download函数
  - `unit` → 'milliseconds'

#### 对于 `@timer(unit='seconds')`

python

```
# upload = timer(unit='seconds')(upload)
```



- `wrapper` 函数闭包中包含：
  - `func` → 原始upload函数
  - `unit` → 'seconds'

### 阶段2：调用阶段（运行时）

#### 调用 `download("example.txt")`

python

```
# 实际执行：wrapper("example.txt")
def wrapper(*args, **kwargs):  # args = ("example.txt",)
    start_time = time.time()
    result = func(*args, **kwargs)  # 调用原始download，unit='milliseconds'来自闭包
    
    # 在原始download中：
    #   print("开始下载文件: example.txt")
    #   time.sleep(2)
    #   print("下载完成")
    #   return "下载文件: example.txt"
    
    end_time = time.time()
    execution_time = end_time - start_time  # 约2.0秒
    
    # 单位转换（因为unit='milliseconds'）
    execution_time *= 1000    # 2000毫秒
    time_unit = "毫秒"
    
    print(f"函数 download 执行耗时: 2000.0000 毫秒")
    return result
```



#### 调用 `upload("example.txt")`

python

```
# 实际执行：wrapper("example.txt")  
def wrapper(*args, **kwargs):  # args = ("example.txt",)
    start_time = time.time()
    result = func(*args, **kwargs)  # 调用原始upload，unit='seconds'来自闭包
    
    # 在原始upload中：
    #   print("开始上传文件: example.txt")  
    #   time.sleep(1.5)
    #   print("上传完成")
    #   return "上传文件: example.txt"
    
    end_time = time.time()
    execution_time = end_time - start_time  # 约1.5秒
    
    # 单位转换（因为unit='seconds'）
    time_unit = "秒"  # 不转换
    
    print(f"函数 upload 执行耗时: 1.5000 秒")
    return result
```



## 三层函数结构说明

text

```
timer(unit)        # 外层：接受装饰器参数
    ↓
返回 decorator(func) # 中层：接受被装饰函数  
    ↓
返回 wrapper(*args, **kwargs) # 内层：实际替换原函数
```



## 预期输出结果

text

```
开始下载文件: example.txt
下载完成
函数 download 执行耗时: 2000.0000 毫秒
开始上传文件: example.txt
上传完成
函数 upload 执行耗时: 1.5000 秒
```



## 关键特点

1. **参数化**：装饰器可以根据参数改变行为
2. **三层嵌套**：外层接受装饰器参数，中层接受函数，内层执行逻辑
3. **闭包机制**：内层函数可以访问外层函数的参数
4. **灵活性**：同一个装饰器可以有不同的配置
