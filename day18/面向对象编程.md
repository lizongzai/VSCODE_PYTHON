# 典型的面向对象编程（OOP）示例

~~~python
# ======================
# 父类（基类）：Person
# ======================
class Person:
    def __init__(self, name, age):
        # 初始化方法（构造函数）
        # self 代表实例对象本身
        self.name = name  # 姓名属性
        self.age = age    # 年龄属性

    def introduce(self):
        """打印自我介绍信息"""
        print(f"你好，我叫 {self.name}，今年 {self.age} 岁。")

    def have_birthday(self):
        """过生日：年龄加 1"""
        self.age += 1
        print(f"祝 {self.name} 生日快乐！现在 {self.age} 岁了。")


# ======================
# 子类：Student（继承自 Person）
# ======================
class Student(Person):
    def __init__(self, name, age, student_id, major):
        # 调用父类构造函数，初始化 name 和 age
        super().__init__(name, age)
        # 添加学生独有的属性
        self.student_id = student_id  # 学号
        self.major = major            # 主修专业
        self.courses = []             # 选课列表（初始为空）

    def introduce(self):
        """重写（override）父类的 introduce 方法"""
        print(f"你好，我是学生 {self.name}，学号 {self.student_id}，"
              f"主修 {self.major}，今年 {self.age} 岁。")

    def enroll_course(self, course_name):
        """学生选课"""
        self.courses.append(course_name)
        print(f"{self.name} 已选课：{course_name}")

    def show_courses(self):
        """展示选课列表"""
        if self.courses:
            print(f"{self.name} 的选课列表：{', '.join(self.courses)}")
        else:
            print(f"{self.name} 还没有选任何课程")


# ======================
# 子类：Teacher（继承自 Person）
# ======================
class Teacher(Person):
    def __init__(self, name, age, department, employee_id):
        # 调用父类构造函数
        super().__init__(name, age)
        # 添加教师特有的属性
        self.department = department   # 所属学院
        self.employee_id = employee_id # 工号

    def introduce(self):
        """重写父类方法，输出教师身份介绍"""
        print(f"大家好，我是 {self.department} 的教师 {self.name}，"
              f"工号 {self.employee_id}。")

    def teach(self):
        """教师特有方法：授课"""
        print(f"{self.name} 老师正在授课...")


# ======================
# 主程序入口（测试代码）
# ======================
if __name__ == "__main__":
    # 创建一个 Person 对象
    person1 = Person("张三", 25)
    person1.introduce()       # 调用父类方法
    person1.have_birthday()   # 调用过生日方法
    print()

    # 创建一个 Student 对象
    student1 = Student("李四", 20, "2024001", "计算机科学")
    student1.introduce()      # 调用重写后的介绍方法
    student1.enroll_course("Python编程")  # 选课
    student1.enroll_course("数据结构")     # 再选一门课
    student1.show_courses()   # 显示选课列表
    print()

    # 创建一个 Teacher 对象
    teacher1 = Teacher("王教授", 45, "计算机学院", "T1001")
    teacher1.introduce()      # 调用重写后的介绍方法
    teacher1.teach()          # 调用教师特有方法
    print()

    # ======================
    # 多态（Polymorphism）演示
    # ======================
    print("=== 多态演示 ===")
    people = [person1, student1, teacher1]  # 不同类型的对象放入同一个列表

    for person in people:
        # 尽管列表中对象类型不同（Person / Student / Teacher），
        # 但都可以调用 introduce() 方法，
        # 实际执行的是各自类中定义的版本（动态绑定）
        person.introduce()

~~~





这是一个**典型的面向对象编程（OOP）示例**，展示了：

- **继承（Inheritance）**
- **方法重写（Override）**
- **多态（Polymorphism）**



我们来逐行解释，让你彻底理解这段代码在干什么👇

------

### 一、父类：`Person`

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

这是父类（基类），表示“人”。
 每个 `Person` 对象都有：

- `name` 姓名
- `age` 年龄





### 二、父类方法

```python
def introduce(self):
    print(f"你好，我叫 {self.name}，今年 {self.age} 岁。")
```

👉 定义了一个介绍自己的方法。
 任何继承自 `Person` 的子类（比如学生、老师）都可以调用或重写这个方法。

```python
def have_birthday(self):
    """过生日，年龄增加1岁"""
    self.age += 1
    print(f"祝 {self.name} 生日快乐！现在 {self.age} 岁了。")
```

👉 模拟“过生日”：让年龄 +1。



### 三、子类：`Student`

```python
class Student(Person):
```

这里表示 `Student` **继承** `Person`，因此拥有 `Person` 的属性和方法。

#### 初始化方法

```python
def __init__(self, name, age, student_id, major):
    super().__init__(name, age)
```

`super().__init__(...)` 是关键点！
 它调用父类 `Person` 的 `__init__`，避免重复代码。
 在此基础上，`Student` 又增加了自己的属性：

- `student_id` 学号
- `major` 专业
- `courses` 选课列表（初始为空）





#### 重写父类方法

```python
def introduce(self):
    print(f"你好，我是学生 {self.name}，学号 {self.student_id}，主修 {self.major}，今年 {self.age} 岁。")
```

这段代码**覆盖（重写）**了父类的 `introduce()` 方法。
 虽然方法名相同，但输出更符合“学生”的身份。





#### 子类独有方法

```python
def enroll_course(self, course_name):
    self.courses.append(course_name)
    print(f"{self.name} 已选课：{course_name}")
```

学生可以选课。

```python
def show_courses(self):
    if self.courses:
        print(f"{self.name} 的选课列表：{', '.join(self.courses)}")
    else:
        print(f"{self.name} 还没有选任何课程")
```

展示课程列表。





### 四、子类：`Teacher`

```python
class Teacher(Person):
```

同样继承自 `Person`，但属性不同：

```python
def __init__(self, name, age, department, employee_id):
    super().__init__(name, age)
    self.department = department
    self.employee_id = employee_id
```

教师属于某个院系，并有工号。





#### 重写方法

```python
def introduce(self):
    print(f"大家好，我是 {self.department} 的教师 {self.name}，工号 {self.employee_id}。")
```

输出教师特有的自我介绍。

```python
def teach(self):
    print(f"{self.name} 老师正在授课...")
```

定义教师专属行为。





### 五、实际使用

在 `if __name__ == "__main__":` 中测试这些类的功能。



### 六、多态演示

```python
people = [person1, student1, teacher1]

for person in people:
    person.introduce()
```

即使都是 `Person` 类型（从语义上讲），
 但实际对象不同（有的是 `Student`，有的是 `Teacher`），
 调用的 `introduce()` 方法也不同。

这就是**多态（Polymorphism）**的体现：

> “同一个方法名，在不同对象中表现出不同的行为。”



✅ **总结一句话：**
 这段代码完整展示了：

- ✅ 类与对象
- ✅ 继承与代码复用
- ✅ 方法重写
- ✅ 多态性
