# 偏函数

偏函数是指固定函数的某些参数，生成一个新的函数，这样就无需在每次调用函数时都传递相同的参数。在 Python 语言中，我们可以使用`functools`模块的`partial`函数来创建偏函数。例如，`int`函数在默认情况下可以将字符串视为十进制整数进行类型转换，如果我们修修改它的`base`参数，就可以定义出三个新函数，分别用于将二进制、八进制、十六进制字符串转换为整数，代码如下所示。



~~~python
import functools

int2 = functools.partial(int, base=2)
int8 = functools.partial(int, base=8)
int16 = functools.partial(int, base=16)

print(int('1001'))    # 1001

print(int2('1001'))   # 9
print(int8('1001'))   # 513
print(int16('1001'))  # 4097
~~~



不知大家是否注意到，`partial`函数的第一个参数和返回值都是函数，它将传入的函数处理成一个新的函数返回。通过构造偏函数，我们可以结合实际的使用场景将原函数变成使用起来更为便捷的新函数，不知道大家有没有觉得这波操作很有意思。

## 第一部分：

### 1️⃣ 基本概念

偏函数的作用：**预先设置函数的部分参数，生成一个新函数**



### 2️⃣ 使用方法

**使用 `functools.partial`**

```python
from functools import partial

# 原始函数
def multiply(a, b, c):
    return a * b * c

# 创建偏函数：固定第一个参数为 2
double = partial(multiply, 2)

print(double(3, 4))  # 输出: 24 (相当于 multiply(2, 3, 4))
print(double(5, 6))  # 输出: 60 (相当于 multiply(2, 5, 6))
```



### 3️⃣实际应用示例

#### **示例1：简化函数调用**

> - [ ] 这是一个计算幂的通用函数：
>
> - `base`: 底数
> - `exponent`: 指数
>
> - [ ] 创建平方函数
>
>   ```
>   square = partial(power, exponent=2)
>   
>   等效的普通函数：
>   
>   def square(base):
>       return power(base, exponent=2)
>       # 也就是 return base ** 2
>   ```
>
>   
>
> - [ ] 创建立方函数
>
>   ```
>   cube = partial(power, exponent=3)
>   
>   等效的普通函数：
>   
>   def cube(base):
>       return power(base, exponent=3)
>       # 也就是 return base ** 3
>   ```
>
>   
>
> - [ ] 执行过程分析
>
>   - [ ] `square(5)` 的执行 
>
>     ```
>     print(square(5))   # 输出: 25
>     
>     内部执行过程：
>     
>     square(5) = power(base=5, exponent=2)
>               = 5 ** 2
>               = 25
>     ```
>
>   - [ ] `square(10)` 的执行
>
>     ```
>     print(square(10))  # 输出: 100
>     
>     内部执行过程：
>     
>     square(10) = power(base=10, exponent=2)
>                = 10 ** 2
>                = 100
>     ```
>
>   - [ ] `cube(3)` 的执行
>
>     ```
>     print(cube(3))     # 输出: 27
>     
>     内部执行过程：
>     
>     cube(3) = power(base=3, exponent=3)
>             = 3 ** 3
>             = 27
>     ```
>
>   - [ ] 可视化理解
>
>     ```
>     原始函数: power(base, exponent)
>         ↓
>     经过 partial(power, exponent=2) 包装
>         ↓
>     新函数: square(base) = power(base, exponent=2)
>     
>     经过 partial(power, exponent=3) 包装  
>         ↓
>     新函数: cube(base) = power(base, exponent=3)
>     ```
>
>     

~~~python
from functools import partial

# 原始函数
def power(base, exponent):
    return base ** exponent

# 创建平方函数（固定 exponent=2）
square = partial(power, exponent=2)

# 创建立方函数（固定 exponent=3）
cube = partial(power, exponent=3)

print(square(5))   # 输出: 25 (5²)
print(square(10))  # 输出: 100 (10²)
print(cube(3))     # 输出: 27 (3³)
~~~

> ### 使用关键字参数（正确）：
>
> python
>
> ```
> square = partial(power, exponent=2)
> # 明确指定固定的是 exponent 参数
> # base 参数留空，等待调用时传入
> ```
>
> 
>
> ### 如果使用位置参数（错误）：
>
> python
>
> ```
> square = partial(power, 2)
> # 这会固定第一个参数 base=2
> # 新函数：square(exponent) = power(2, exponent)
> # 这就变成了计算 2的exponent次方，不是我们想要的！
> ```





#### 示例2：配置默认参数**

```python
from functools import partial

# 网络请求函数
def make_request(url, method='GET', timeout=30, headers=None):
    print(f"请求: {method} {url}, 超时: {timeout}秒")
    # 实际网络请求逻辑...

# 创建特定配置的请求函数
api_get = partial(make_request, method='GET', timeout=60)
api_post = partial(make_request, method='POST')

# 使用简化后的函数
api_get('https://api.example.com/users')
api_post('https://api.example.com/users', timeout=10)
```



#### **示例3：与 map 函数结合**

```python
from functools import partial

def greet(greeting, name):
    return f"{greeting}, {name}!"

# 固定问候语
say_hello = partial(greet, "Hello")
say_hi = partial(greet, "Hi")

names = ["Alice", "Bob", "Charlie"]

# 使用偏函数映射
hello_messages = list(map(say_hello, names))
hi_messages = list(map(say_hi, names))

print(hello_messages)  # ['Hello, Alice!', 'Hello, Bob!', 'Hello, Charlie!']
print(hi_messages)     # ['Hi, Alice!', 'Hi, Bob!', 'Hi, Charlie!']
```





### 4️⃣ 偏函数 vs Lambda

**使用偏函数：**

```python
from functools import partial

def multiply(a, b):
    return a * b

double = partial(multiply, 2)
```



**使用 Lambda：**

```
double = lambda b: multiply(2, b)
```



**两者效果相同**，但偏函数通常：

- 性能更好
- 调试信息更清晰
- 代码更易读



### 5️⃣ 在之前 calc 函数中的应用

~~~python
from functools import partial
import operator

def calc(init_value, op_func, *args, **kwargs):
    items = list(args) + list(kwargs.values())
    result = init_value
    for item in items:
        if type(item) in (int, float):
            result = op_func(result, item)
    return result

# 使用偏函数创建特定功能的计算器
sum_calculator = partial(calc, 0, operator.add)
product_calculator = partial(calc, 1, operator.mul)

print(sum_calculator(1, 2, 3, 4, 5))      # 输出: 15
print(product_calculator(2, 3, 4, 5))     # 输出: 120
~~~



**注意事项**

```python
from functools import partial

def func(a, b, c, d):
    return a + b + c + d

# 偏函数按顺序固定参数
p1 = partial(func, 1, 2)      # 固定 a=1, b=2
print(p1(3, 4))               # 输出: 10 (1+2+3+4)

# 也可以使用关键字参数
p2 = partial(func, d=10)      # 固定 d=10
print(p2(1, 2, 3))            # 输出: 16 (1+2+3+10)
```





### 6️⃣**调度过程附加内容**

~~~python
from functools import partial

# 原始函数
def multiply(a, b, c):
    return a * b * c

# 创建偏函数：固定第一个参数为 2
double = partial(multiply, 2)

print(double(3, 4))  # 输出: 24 (相当于 multiply(2, 3, 4))
print(double(5, 6))  # 输出: 60 (相当于 multiply(2, 5, 6))
~~~



**1. 执行过程分析**

*第一次调用：`double(3, 4)`*

```
print(double(3, 4))
```



**2. 内部执行过程：**

python

```python
# double 实际上是这样执行的：
double(3, 4) = multiply(2, 3, 4)
             = 2 * 3 * 4
             = 24
```



**3. 参数对应关系：**

```
原始函数：multiply(a, b, c)
偏函数：  double(b, c) = multiply(2, b, c)

调用 double(3, 4):
b = 3, c = 4
→ multiply(2, 3, 4)
```



*第二次调用：`double(5, 6)`*

```
print(double(5, 6))
```



**1. 内部执行过程：**

```
double(5, 6) = multiply(2, 5, 6)
             = 2 * 5 * 6
             = 60
```



**2. 可视化理解**

可以把 `partial` 想象成一个**函数包装器**：

```
原始函数: multiply(a, b, c)
    ↓
经过 partial(multiply, 2) 包装
    ↓
新函数: double(b, c) = multiply(2, b, c)
```



**3. 等效的普通函数写法**

偏函数：

```
double = partial(multiply, 2)
```



等价于：

```
def double(b, c):
    return multiply(2, b, c)
```

